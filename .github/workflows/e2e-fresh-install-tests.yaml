name: E2E Fresh Install Tests

on:
  workflow_dispatch: # Allows manual triggering
  pull_request:
    branches:
      - '**'
    # paths filter removed to always trigger

  push:
    branches:
      - main
    # paths filter removed to always trigger

jobs:
  fresh-install-e2e:
    runs-on: ubuntu-latest
    timeout-minutes: 30 # Set a timeout for the job

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history for all branches and tags, required for tj-actions/changed-files

      #--------------------------------------------------------------
      # Detect whether the proposed changes require running the
      # (slow) E2E installation tests.  If the pull-request only
      # touches the Helm chart (which lives in the `helm/` folder)
      # we can safely skip the remainder of the workflow because the
      # chart does not influence the application code executed inside
      # these containers.
      #--------------------------------------------------------------
      - name: Check for relevant file changes
        id: changed_files_check
        uses: tj-actions/changed-files@v42 # Using a specific version
        with:
          # List of paths that, when modified, SHOULD trigger the heavy
          # E2E job.  **Notice that the `helm/**` path is intentionally
          # omitted** so that commits exclusively touching Helm logic
          # will set `any_changed` to `false`.
          files: |
            .github/workflows/e2e-fresh-install-tests.yaml
            docker-compose.base.yaml
            docker-compose.ce.yaml
            server/**
            setup/**
            shared/**
            e2e-tests/**

      # Short-circuit the job if no relevant files changed (i.e. only
      # Helm-chart related modifications).  GitHub marks a job as
      # successful when all executed steps succeed, so emitting an
      # informative log and exiting early is sufficient.
      - name: Skip job -- only Helm chart files changed
        if: steps.changed_files_check.outputs.any_changed == 'false'
        run: |
          echo "Only Helm chart-related files were modified â€“ skipping E2E Fresh Install Tests."
          echo "No further steps will be executed."
          # Nothing else to do, the job will report success because the
          # previous steps (including this one) have succeeded.


      - name: Set up test environment secrets and .env
        if: steps.changed_files_check.outputs.any_changed == 'true'
        run: |
          # Create secrets directory
          mkdir -p secrets

          # Create sample secrets (placeholders, real values not needed for this test if services are self-contained)
          # Using similar placeholders as pr-checks.yaml for consistency
          echo "placeholder-password" > secrets/postgres_password
          echo "placeholder-password" > secrets/db_password_server
          echo "placeholder-password" > secrets/db_password_hocuspocus
          echo "placeholder-password" > secrets/redis_password
          echo "placeholder-key-32-chars-long-01" > secrets/alga_auth_key
          echo "placeholder-key-32-chars-long-02" > secrets/crypto_key
          echo "placeholder-key-32-chars-long-03" > secrets/token_secret_key
          echo "placeholder-key-32-chars-long-04" > secrets/nextauth_secret
          echo "placeholder-password" > secrets/email_password
          echo "placeholder-id" > secrets/google_oauth_client_id
          echo "placeholder-secret" > secrets/google_oauth_client_secret

          # Set permissions
          chmod 600 secrets/*

          # Copy and configure environment file
          cp .env.example .env

          # Configure required environment variables for the test
          # Set APP_ENV to production for production build testing
          cat >> .env << EOL
          APP_VERSION=1.0.0-e2e
          APP_NAME=alga-e2e-test
          APP_ENV=production
          APP_HOST=0.0.0.0
          APP_PORT=3000
          APP_EDITION=community

          # Database Configuration (will be overridden by docker-compose services but good to have)
          DB_TYPE=postgres
          DB_USER_ADMIN=postgres

          # Logging Configuration
          LOG_LEVEL=INFO
          LOG_IS_FORMAT_JSON=false
          LOG_IS_FULL_DETAILS=false

          # Email Configuration (disabled for tests)
          EMAIL_ENABLE=false

          # Authentication Configuration
          NEXTAUTH_URL=http://localhost:3000
          NEXTAUTH_SESSION_EXPIRES=86400

          # Optional Configuration
          REQUIRE_HOCUSPOCUS=false
          
          # Secret Provider Configuration (override production defaults)
          SECRET_READ_CHAIN=env,filesystem
          SECRET_WRITE_PROVIDER=filesystem
          EOL
        shell: bash

      - name: Temporarily rename root docker-compose.yaml to avoid conflict in act
        if: env.ACT
        run: |
          if [ -f docker-compose.yaml ]; then
            echo "Temporarily renaming root docker-compose.yaml to docker-compose.yaml.ignored"
            sudo mv docker-compose.yaml docker-compose.yaml.ignored
          fi
        shell: bash

      - name: Install Docker Compose v1.29.2 via curl
        if: steps.changed_files_check.outputs.any_changed == 'true'
        id: install_docker_compose # Add an ID for dependent steps
        run: |
          COMPOSE_VERSION="v2.36.0"
          COMPOSE_URL="https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)"
          DEST_PATH="/usr/local/bin/docker-compose" # Standard location

          echo "Downloading Docker Compose from ${COMPOSE_URL} to ${DEST_PATH}"
          sudo rm -f "${DEST_PATH}" # Remove existing to avoid conflicts
          # Use curl with -fS (fail silently on server errors, show client errors) and -L (follow redirects)
          sudo curl -fSL "${COMPOSE_URL}" -o "${DEST_PATH}"
          
          # Verify download was successful and file is not empty and is executable
          if [ ! -s "${DEST_PATH}" ]; then
            echo "Error: Downloaded docker-compose is empty. URL ${COMPOSE_URL} might be incorrect or file not found."
            exit 1
          fi
          if ! file "${DEST_PATH}" | grep -q "executable"; then
            echo "Error: Downloaded file at ${DEST_PATH} is not an executable. It might be an HTML error page."
            echo "Downloaded content (first 5 lines):"
            sudo head -n 5 "${DEST_PATH}"
            exit 1
          fi
          
          sudo chmod +x "${DEST_PATH}"
          echo "Docker Compose version:"
          docker-compose --version # Verify installation
        shell: bash

      - name: Start foundational services (postgres and redis)
        if: steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Starting foundational services: postgres and redis"
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml up --build -d postgres redis
        shell: bash

      - name: Wait for postgres to be ready
        if: steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Waiting for postgres to be ready..."
          
          # Wait for postgres to be healthy
          echo "Checking postgres health..."
          MAX_ATTEMPTS=30
          ATTEMPT_NUM=1
          until docker-compose -p alga-e2e-test exec -T postgres pg_isready -U postgres; do
            if [ $ATTEMPT_NUM -ge $MAX_ATTEMPTS ]; then
              echo "Timeout: Postgres did not become ready within the allocated time."
              docker-compose -p alga-e2e-test logs postgres
              exit 1
            fi
            echo "Attempt $ATTEMPT_NUM/$MAX_ATTEMPTS: Postgres not ready. Waiting 5 seconds..."
            sleep 5
            ATTEMPT_NUM=$((ATTEMPT_NUM+1))
          done
          echo "Postgres is ready."
        shell: bash

      - name: Start pgbouncer service
        if: steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Starting pgbouncer service"
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml up --build -d pgbouncer
        shell: bash

      - name: Wait for pgbouncer to be ready
        if: steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Waiting for pgbouncer to be ready..."
          
          # Wait for pgbouncer port to be open
          echo "Checking pgbouncer port availability..."
          MAX_ATTEMPTS=30
          ATTEMPT_NUM=1
          until docker run --rm --network alga-e2e-test_app-network busybox nc -z pgbouncer 6432; do
            if [ $ATTEMPT_NUM -ge $MAX_ATTEMPTS ]; then
              echo "Timeout: PgBouncer port did not become available within the allocated time."
              docker-compose -p alga-e2e-test logs pgbouncer
              exit 1
            fi
            echo "Attempt $ATTEMPT_NUM/$MAX_ATTEMPTS: PgBouncer port not ready. Waiting 5 seconds..."
            sleep 5
            ATTEMPT_NUM=$((ATTEMPT_NUM+1))
          done
          echo "PgBouncer port is ready."
          
          # Additional wait for pgbouncer to fully initialize
          echo "Waiting additional 5 seconds for pgbouncer to fully initialize..."
          sleep 5
        shell: bash

      - name: Start setup service (Ubuntu build override)
        if: steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Starting setup service"
          docker-compose -p alga-e2e-test \
            -f docker-compose.base.yaml \
            -f docker-compose.ce.yaml \
            -f docker-compose.prod.yaml \
            -f docker-compose.setup-ubuntu.override.yaml \
            up --build -d setup
        shell: bash

      - name: Wait for Setup service to complete (Ubuntu build override)
        if: steps.install_docker_compose.outcome == 'success'
        id: wait_for_setup
        run: |
          echo "Waiting for setup service to complete..."
          MAX_ATTEMPTS=60 # 10 minutes (60 attempts * 10 seconds)
          ATTEMPT_NUM=1
          
          # Get the container ID before the loop, it might be gone after exit
          SETUP_CONTAINER_ID=$(docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml -f docker-compose.setup-ubuntu.override.yaml ps -q setup)
          if [ -z "$SETUP_CONTAINER_ID" ]; then
            echo "Critical: Could not get initial container ID for setup service. Assuming it failed to start."
            docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml -f docker-compose.setup-ubuntu.override.yaml logs setup
            echo "::set-output name=status::failure"
            exit 1
          fi
          echo "Monitoring Setup Container ID: $SETUP_CONTAINER_ID"

          while [ $ATTEMPT_NUM -le $MAX_ATTEMPTS ]; do
            # Check if the setup container is still running
            if ! docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml -f docker-compose.setup-ubuntu.override.yaml ps setup | grep -q "Up"; then
              # Container has exited, check its exit code using the stored ID
              echo "Setup container (ID: $SETUP_CONTAINER_ID) is no longer 'Up'. Checking exit code."
              # Use the stored SETUP_CONTAINER_ID
              if [ -z "$SETUP_CONTAINER_ID" ]; then # Should not happen if initial check passed
                echo "Error: Lost setup container ID." # Should be redundant due to initial check
                SETUP_EXIT_CODE="1" 
              else
                echo "Inspecting container ID: $SETUP_CONTAINER_ID"
                INSPECT_OUTPUT=$(docker inspect -f '{{.State.ExitCode}} {{.State.Error}}' "$SETUP_CONTAINER_ID" 2>/dev/null)
                echo "Inspect output: '$INSPECT_OUTPUT'"
                SETUP_EXIT_CODE=$(echo "$INSPECT_OUTPUT" | awk '{print $1}')
                # If SETUP_EXIT_CODE is empty or not a number, default to 1
                if ! [[ "$SETUP_EXIT_CODE" =~ ^[0-9]+$ ]]; then
                    echo "Failed to parse exit code from inspect output, defaulting to 1."
                    SETUP_EXIT_CODE="1"
                fi
              fi
              
              echo "Reported Setup Exit Code: $SETUP_EXIT_CODE"
              if [ "$SETUP_EXIT_CODE" -eq 0 ]; then
                echo "Setup service completed successfully."
                echo "::set-output name=status::success"
                exit 0
              else
                echo "Setup service failed with exit code $SETUP_EXIT_CODE."
                docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml -f docker-compose.setup-ubuntu.override.yaml logs setup
                echo "::set-output name=status::failure"
                exit 1
              fi
            fi

            # Check logs for completion message as a secondary check (optional, primary is exit code)
            if docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml -f docker-compose.setup-ubuntu.override.yaml logs setup | grep -q "Setup completed!"; then
               echo "Setup completion message found in logs. Waiting a bit for container to exit."
               sleep 5 # Give it a moment to exit gracefully
               # Re-check exit status using the stored ID
                if ! docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml -f docker-compose.setup-ubuntu.override.yaml ps setup | grep -q "Up"; then
                    # Use the stored SETUP_CONTAINER_ID
                    INSPECT_OUTPUT_LOG_CHECK=$(docker inspect -f '{{.State.ExitCode}}' "$SETUP_CONTAINER_ID" 2>/dev/null)
                    SETUP_EXIT_CODE_LOG_CHECK=$(echo "$INSPECT_OUTPUT_LOG_CHECK" | awk '{print $1}')
                    if ! [[ "$SETUP_EXIT_CODE_LOG_CHECK" =~ ^[0-9]+$ ]]; then
                        echo "Failed to parse exit code from inspect output (log check), defaulting to 1."
                        SETUP_EXIT_CODE_LOG_CHECK="1"
                    fi

                    if [ "$SETUP_EXIT_CODE_LOG_CHECK" -eq 0 ]; then
                        echo "Setup service completed successfully after log check (Exit Code: $SETUP_EXIT_CODE_LOG_CHECK)."
                        echo "::set-output name=status::success"
                        exit 0 # Successful exit from the script
                    else
                        echo "Setup service showed completion log but exited with code $SETUP_EXIT_CODE_LOG_CHECK."
                        docker-compose -p alga-e2e-test logs setup
                        echo "::set-output name=status::failure"
                        exit 1 # Failed exit from the script
                    fi
                fi
            fi

            echo "Attempt $ATTEMPT_NUM/$MAX_ATTEMPTS: Setup service still running. Waiting 10 seconds..."
            sleep 10
            ATTEMPT_NUM=$((ATTEMPT_NUM+1))
          done
          echo "Timeout: Setup service did not complete within the allocated time."
          docker-compose -p alga-e2e-test logs
          echo "::set-output name=status::failure"
          exit 1
        shell: bash

      - name: Start remaining services after setup completion
        if: steps.wait_for_setup.outputs.status == 'success' && steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Setup completed successfully. Starting remaining services..."
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml up --build -d
        shell: bash

      - name: Collect initial container logs
        if: steps.wait_for_setup.outputs.status == 'success' && steps.install_docker_compose.outcome == 'success'
        run: |
          echo "=== CONTAINER STATUS ==="
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml ps
          
          echo -e "\n=== ALL CONTAINER LOGS ==="
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml logs --tail=100
          
          echo -e "\n=== SERVER LOGS (detailed) ==="
          docker-compose -p alga-e2e-test logs server --tail=200
        shell: bash

      - name: Wait for Server service to be healthy
        if: steps.wait_for_setup.outputs.status == 'success' && steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Waiting for server service to be healthy..."
          MAX_ATTEMPTS=30 # 5 minutes (30 attempts * 10 seconds) - keep original timeout
          ATTEMPT_NUM=1
          APP_PORT_VALUE=$(grep APP_PORT .env | cut -d '=' -f2 | head -n 1 || echo "3000")
          
          # Hit the Next.js API health endpoints so database connectivity is exercised
          HEALTH_CHECK_URL="http://localhost:${APP_PORT_VALUE}/api/health"
          
          # Additional readiness check - verify the richer readiness probe
          READINESS_CHECK_URL="http://localhost:${APP_PORT_VALUE}/api/readyz"
          
          echo "Using health check URL: $HEALTH_CHECK_URL"
          echo "Using readiness check URL: $READINESS_CHECK_URL"

          until curl --output /dev/null --silent --fail "$HEALTH_CHECK_URL" && \
                curl --output /dev/null --silent --fail "$READINESS_CHECK_URL"; do
            if [ $ATTEMPT_NUM -ge $MAX_ATTEMPTS ]; then
              echo "Timeout: Server service did not become healthy within the allocated time."
              echo "=== FINAL SERVER LOGS ==="
              docker-compose -p alga-e2e-test logs server --tail=500
              echo "=== ALL CONTAINER STATUS ==="
              docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml ps
              exit 1
            fi
            echo "Attempt $ATTEMPT_NUM/$MAX_ATTEMPTS: Server not yet fully ready. Waiting 10 seconds..."
            
            # Show server logs every 5 attempts to debug issues
            if [ $((ATTEMPT_NUM % 5)) -eq 0 ]; then
              echo "=== SERVER LOGS (attempt $ATTEMPT_NUM) ==="
              docker-compose -p alga-e2e-test logs server --tail=50
            fi
            
            sleep 10
            ATTEMPT_NUM=$((ATTEMPT_NUM+1))
          done
          echo "Server service is healthy and ready at $HEALTH_CHECK_URL and $READINESS_CHECK_URL."
          
          # Additional wait to ensure the application is fully initialized
          echo "Waiting additional 15 seconds for application to fully initialize..."
          sleep 15
        shell: bash

      - name: Skip tenant onboarding requirement
        if: steps.wait_for_setup.outputs.status == 'success' && steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Marking onboarding as skipped for all tenants to unblock dashboard access..."
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml exec -T postgres \
            psql -U postgres -d server <<'SQL'
          DO $do$
          BEGIN
            IF EXISTS (
              SELECT 1
              FROM information_schema.tables
              WHERE table_schema = 'public' AND table_name = 'tenant_settings'
            ) THEN
              INSERT INTO tenant_settings (tenant, onboarding_skipped, onboarding_completed, onboarding_completed_at, updated_at)
              SELECT tenant, true, false, NULL, NOW()
                FROM tenants
              ON CONFLICT (tenant) DO UPDATE
                SET onboarding_skipped = true,
                    updated_at = NOW();
            ELSE
              RAISE NOTICE 'tenant_settings table not found; skipping onboarding override';
            END IF;
          END;
          $do$;
          SQL
        shell: bash

      - name: Trigger Login Page to Generate Credentials
        if: steps.wait_for_setup.outputs.status == 'success' && steps.install_docker_compose.outcome == 'success'
        run: |
          echo "Attempting to trigger login page to generate credentials in server logs..."
          APP_PORT_VALUE=$(grep APP_PORT .env | cut -d '=' -f2 | head -n 1 || echo "3000")
          LOGIN_PAGE_URL="http://localhost:${APP_PORT_VALUE}/auth/signin"
          curl -s -o /dev/null -w "%{http_code}" "${LOGIN_PAGE_URL}" || echo "Curl to login page finished (ignore exit code here)."
          echo "Login page triggered. Waiting a few seconds for logs to propagate..."
          sleep 3
        shell: bash

      - name: Capture Credentials from Server Logs
        if: steps.wait_for_setup.outputs.status == 'success' && steps.install_docker_compose.outcome == 'success'
        id: capture_creds
        run: |
          echo "Attempting to capture credentials from server logs..."

          APP_PORT_VALUE=$(grep APP_PORT .env | cut -d '=' -f2 | head -n 1 || echo "3000")
          LOGIN_PAGE_URL="http://localhost:${APP_PORT_VALUE}/auth/signin"

          CREDENTIAL_LINES=$(LOGIN_PAGE_URL="$LOGIN_PAGE_URL" timeout 90 bash -s <<'EOS'
            set -euo pipefail

            email=""
            password=""

            (curl -s -o /dev/null "$LOGIN_PAGE_URL" || true) &
            trigger_pid=$!

            while IFS= read -r raw_line; do
              cleaned=$(printf "%s" "$raw_line" | tr -d "\r" | sed -E "s/\\x1B\\[[0-9;]*[[:alpha:]]//g")

              if [[ $cleaned == *"User Email is ->"* ]]; then
                email=$(printf "%s\n" "$cleaned" | sed -E "s/.*\\[ ([^ ]+) \\].*/\\1/")
              elif [[ $cleaned == *"Password is ->"* ]]; then
                password=$(printf "%s\n" "$cleaned" | sed -E "s/.*\\[ ([^ ]+) \\].*/\\1/")
              fi

              if [[ -n $email && -n $password ]]; then
                printf "%s\n%s\n" "$email" "$password"
                kill $trigger_pid >/dev/null 2>&1 || true
                exit 0
              fi
            done < <(docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml logs --no-color --tail 0 --follow server)

            exit 1
          EOS
          )

          STATUS=$?
          if [ $STATUS -ne 0 ] || [ -z "$CREDENTIAL_LINES" ]; then
            echo "Failed to capture credentials from server logs within timeout."
            exit 1
          fi

          USER_EMAIL=$(printf '%s\n' "$CREDENTIAL_LINES" | head -n 1 | tr -d '\n')
          USER_PASSWORD=$(printf '%s\n' "$CREDENTIAL_LINES" | tail -n 1 | tr -d '\n')

          USER_PASSWORD_B64=$(printf '%s' "$USER_PASSWORD" | base64)

          {
            echo "e2e_user_email=$USER_EMAIL"
            echo "e2e_user_password_b64=$USER_PASSWORD_B64"
          } >> "$GITHUB_OUTPUT"

          echo "Successfully extracted credentials."
          echo "E2E email: $USER_EMAIL"
          echo "Password length: ${#USER_PASSWORD}"
          echo "::add-mask::$USER_PASSWORD"
        shell: bash

      - name: Set up Node.js
        if: steps.wait_for_setup.outputs.status == 'success'
        uses: actions/setup-node@v3
        with:
          node-version: '18' # Or your project's Node version

      - name: Create E2E test directory and package.json
        if: steps.wait_for_setup.outputs.status == 'success'
        run: |
          mkdir -p e2e-tests/tests
          cat << EOF > e2e-tests/package.json
          {
            "name": "alga-e2e-tests",
            "version": "1.0.0",
            "description": "E2E tests for Alga PSA",
            "main": "index.js",
            "scripts": {
              "test": "playwright test"
            },
            "keywords": [],
            "author": "",
            "license": "ISC",
            "devDependencies": {
              "@playwright/test": "^1.40.0"
            }
          }
          EOF
        shell: bash

      - name: Install Playwright and dependencies
        if: steps.wait_for_setup.outputs.status == 'success'
        working-directory: ./e2e-tests
        run: |
          npm install
          npx playwright install --with-deps # Install browsers
        shell: bash

      - name: Create Playwright config file
        if: steps.wait_for_setup.outputs.status == 'success'
        run: |
          cat << EOF > e2e-tests/playwright.config.ts
          import { defineConfig, devices } from '@playwright/test';

          export default defineConfig({
            testDir: './tests',
            fullyParallel: true,
            forbidOnly: !!process.env.CI,
            retries: process.env.CI ? 3 : 0, // Increased retries for CI
            workers: process.env.CI ? 1 : undefined,
            reporter: [
              ['html'],
              ['json', { outputFile: 'test-results/results.json' }],
              ['junit', { outputFile: 'test-results/results.xml' }]
            ],
            timeout: 180000, // 3 minutes global timeout (increased)
            expect: {
              timeout: 30000 // 30 seconds for expect assertions
            },
            use: {
              baseURL: process.env.E2E_BASE_URL || 'http://localhost:3000',
              trace: 'on-first-retry',
              screenshot: 'only-on-failure',
              video: 'retain-on-failure',
              actionTimeout: 60000, // 60 seconds for actions
              navigationTimeout: 120000, // 120 seconds for navigation (increased)
            },
            projects: [
              {
                name: 'chromium',
                use: { 
                  ...devices['Desktop Chrome'],
                  viewport: { width: 1280, height: 720 }
                },
              },
            ],
          });
          EOF
        shell: bash

      - name: Create E2E login test spec
        if: steps.wait_for_setup.outputs.status == 'success'
        run: |
          # Ensure APP_PORT is available for constructing the baseURL if not set via E2E_BASE_URL
          APP_PORT_VALUE_FROM_ENV=$(grep '^APP_PORT=' ./.env | cut -d '=' -f2 | head -n 1)
          APP_PORT_VALUE=${APP_PORT_VALUE_FROM_ENV:-3000}
          BASE_URL="http://localhost:${APP_PORT_VALUE}"
          echo "Resolved BASE_URL for Playwright spec: ${BASE_URL}"

          cat << EOF > e2e-tests/tests/login.spec.ts
          import { test, expect } from '@playwright/test';

          test.describe('Login Functionality', () => {
            test('should allow a user to log in and redirect to dashboard', async ({ page }) => {
              const email = process.env.E2E_USER_EMAIL;
              const password = process.env.E2E_USER_PASSWORD;
              const baseUrl = process.env.E2E_BASE_URL || '${BASE_URL}'; // Use env var or default

              if (!email || !password) {
                throw new Error('E2E_USER_EMAIL or E2E_USER_PASSWORD environment variables are not set.');
              }

              console.log('Starting login test with email:', email);
              console.log('Base URL:', baseUrl);

              // Navigate to the login page with retry logic
              let loginPageLoaded = false;
              for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                  console.log(\`Attempt \${attempt}/3: Navigating to login page...\`);
                  await page.goto(\`\${baseUrl}/auth/signin\`, { waitUntil: 'networkidle', timeout: 30000 });
                  loginPageLoaded = true;
                  break;
                } catch (error) {
                  console.log(\`Attempt \${attempt} failed: \${error.message}\`);
                  if (attempt === 3) throw error;
                  await page.waitForTimeout(5000); // Wait 5 seconds before retry
                }
              }

              if (!loginPageLoaded) {
                throw new Error('Failed to load login page after 3 attempts');
              }

              console.log('Login page loaded successfully');

              // Wait for the page to be fully interactive
              await page.waitForLoadState('networkidle');

              // Fill in the email and password with better error handling
              try {
                console.log('Waiting for email field...');
                await page.waitForSelector('input[id="msp-email-field"]', { timeout: 30000 });
                await page.fill('input[id="msp-email-field"]', email);
                console.log('Email field filled');

                console.log('Waiting for password field...');
                await page.waitForSelector('input[id="msp-password-field"]', { timeout: 10000 });
                await page.fill('input[id="msp-password-field"]', password);
                console.log('Password field filled');
              } catch (e) {
                console.error('Error filling form fields. Current page HTML:', await page.content());
                throw e;
              }

              // Click the login button with better error handling
              try {
                console.log('Waiting for sign-in button...');
                await page.waitForSelector('button[id="msp-sign-in-button"]', { timeout: 10000 });
                console.log('Clicking sign-in button...');
                await page.click('button[id="msp-sign-in-button"]');
                console.log('Sign-in button clicked');
              } catch (e) {
                console.error('Error clicking sign-in button. Current page HTML:', await page.content());
                throw e;
              }

              // Wait for navigation to the dashboard with better error handling
              console.log(\`Current URL before waiting for dashboard: \${page.url()}\`);
              console.log(\`Waiting for URL: \${baseUrl}/msp/dashboard with 90s timeout.\`);

              try {
                // Use multiple wait strategies for better reliability
                await Promise.race([
                  page.waitForURL(\`\${baseUrl}/msp/dashboard\`, { timeout: 90000, waitUntil: 'networkidle' }),
                  page.waitForSelector('[data-testid="dashboard"]', { timeout: 90000 }),
                  page.waitForSelector('h1', { timeout: 90000 })
                ]);
                
                console.log(\`Successfully navigated to dashboard. Current URL: \${page.url()}\`);

                // Additional verification that we're actually on the dashboard
                const currentUrl = page.url();
                if (!currentUrl.includes('/msp/dashboard')) {
                  console.warn('Warning: URL does not contain /msp/dashboard, but navigation completed');
                  console.log('Actual URL:', currentUrl);
                }

                // Assert that the URL is the dashboard URL
                expect(page.url()).toBe(\`\${baseUrl}/msp/dashboard\`);

                // Additional check for dashboard content
                await page.waitForSelector('h1', { timeout: 10000 });
                const pageTitle = await page.title();
                console.log('Page title:', pageTitle);

              } catch (error) {
                console.error('Error waiting for dashboard navigation:', error);
                console.log('Current page URL:', page.url());
                console.log('Current page content:', await page.content());
                throw error;
              }

              console.log('Login test completed successfully');
            });
          });
          EOF
        working-directory: ./
        shell: bash


      - name: Run Playwright E2E tests
        if: steps.wait_for_setup.outputs.status == 'success' && steps.capture_creds.outputs.e2e_user_email != ''
        working-directory: ./e2e-tests
        run: |
          export E2E_USER_EMAIL="${{ steps.capture_creds.outputs.e2e_user_email }}"
          export E2E_USER_PASSWORD="$(printf '%s' "${{ steps.capture_creds.outputs.e2e_user_password_b64 }}" | base64 --decode | tr -d '\n')"

          npx playwright test
        shell: bash

      - name: Collect all container logs on failure
        if: failure() && steps.install_docker_compose.outcome == 'success'
        run: |
          echo "=== COLLECTING ALL LOGS DUE TO FAILURE ==="
          
          echo "=== CONTAINER STATUS ==="
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml ps || echo "Could not get container status"
          
          echo -e "\n=== DOCKER SYSTEM INFO ==="
          docker system df
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
          
          echo -e "\n=== ALL CONTAINER LOGS ==="
          docker-compose -p alga-e2e-test logs --tail=1000 || echo "Could not get compose logs"
          
          echo -e "\n=== INDIVIDUAL SERVICE LOGS ==="
          for service in server setup postgres redis pgbouncer hocuspocus workflow-worker; do
            echo "--- $service logs ---"
            docker-compose -p alga-e2e-test logs $service --tail=200 2>/dev/null || echo "No logs for $service"
          done
          
          echo -e "\n=== DOCKER INSPECT (running containers) ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep alga-e2e-test || echo "No running containers found"
          
          # Try to get logs from any containers that might have the project name
          echo -e "\n=== DIRECT DOCKER LOGS ==="
          for container in $(docker ps -a --filter "name=alga-e2e-test" --format "{{.Names}}"); do
            echo "--- Direct logs for $container ---"
            docker logs $container --tail=100 2>/dev/null || echo "Could not get logs for $container"
          done
        shell: bash

      - name: Save container logs as artifacts
        if: always() && steps.install_docker_compose.outcome == 'success'
        run: |
          mkdir -p logs
          
          # Save logs for each service
          for service in server setup postgres redis pgbouncer hocuspocus workflow-worker; do
            echo "Saving logs for $service..."
            docker-compose -p alga-e2e-test logs $service --no-color > "logs/${service}.log" 2>/dev/null || echo "No logs for $service" > "logs/${service}.log"
          done
          
          # Save combined logs
          docker-compose -p alga-e2e-test logs --no-color > "logs/all-services.log" 2>/dev/null || echo "Could not save combined logs"
          
          # Save container status
          docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml ps > "logs/container-status.txt" 2>/dev/null || echo "Could not save container status"
          
          # Save environment info
          echo "Environment variables:" > logs/environment.txt
          env | grep -E "(APP_|NODE_|DB_|REDIS_)" >> logs/environment.txt || echo "Could not save environment"
          
          ls -la logs/
        shell: bash

      - name: Upload logs as artifacts
        if: always() && steps.install_docker_compose.outcome == 'success' && github.actor != 'nektos/act'
        uses: actions/upload-artifact@v4
        with:
          name: container-logs
          path: logs/
          retention-days: 7

      # - name: Upload Playwright Test Report
      #   if: always() && steps.changed_files_check.outputs.any_changed == 'true' && steps.wait_for_setup.outputs.status == 'success' && !env.ACT # Run even if tests fail, but setup was ok. Skip in ACT due to token issues.
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: playwright-report
      #     path: e2e-tests/playwright-report/
      #     retention-days: 7

      - name: Cleanup Docker Compose
        if: always() && steps.install_docker_compose.outcome == 'success' # Ensure docker-compose was attempted to be installed
        run: |
          echo "Cleaning up Docker Compose environment..."
          # Check if docker-compose command is available before trying to use it
          if command -v docker-compose &> /dev/null; then
            docker-compose -p alga-e2e-test -f docker-compose.base.yaml -f docker-compose.ce.yaml -f docker-compose.prod.yaml down -v --remove-orphans || echo "Docker Compose cleanup failed, but continuing."
          else
            echo "docker-compose command not found, skipping cleanup."
          fi
        shell: bash

      - name: Restore root docker-compose.yaml
        if: always() && env.ACT
        run: |
          if [ -f docker-compose.yaml.ignored ]; then
            echo "Restoring root docker-compose.yaml"
            sudo mv docker-compose.yaml.ignored docker-compose.yaml
          fi
        shell: bash
