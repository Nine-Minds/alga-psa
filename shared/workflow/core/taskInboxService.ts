import type { Knex } from 'knex';
import { v4 as uuidv4 } from 'uuid';
import WorkflowTaskModel, { IWorkflowTask, WorkflowTaskStatus } from '../persistence/workflowTaskModel.js';
import { TaskCreationParams, TaskEventNames } from '../persistence/taskInboxInterfaces.js';
import { getWorkflowRuntime } from './workflowRuntime.js';
import { getFormRegistry } from './formRegistry.js';
import { ActionRegistry, ActionExecutionContext, ActionParameterDefinition } from './actionRegistry.js';

/**
 * Extended context for workflow actions with additional properties needed for task creation
 */
interface TaskActionContext extends ActionExecutionContext {
  knex: Knex;
  userId?: string;
  tenant: string;
  executionId: string;
}

/**
 * Service for managing workflow tasks in the Task Inbox system
 */
export class TaskInboxService {
  /**
   * Create a new task in the Task Inbox
   * 
   * @param knex Knex instance
   * @param tenant Tenant ID
   * @param executionId Workflow execution ID
   * @param params Task creation parameters
   * @param userId User ID of the creator
   * @returns The created task ID
   */
  async createTask(
    knex: Knex,
    tenant: string,
    executionId: string,
    params: TaskCreationParams,
    userId?: string
  ): Promise<string> {
    try {
      // taskId is generated by WorkflowTaskModel.createTask

      let resolvedDefinitionType: 'tenant' | 'system';
      let formTypeForNewDef: 'tenant' | 'system';
      let tenantTaskDefinitionIdForTask: string | null = null;
      let systemTaskDefinitionTaskTypeForTask: string | null = null;

      // 1. Attempt to find tenantTaskDef
      const tenantTaskDef = await knex('workflow_task_definitions')
        .where({
          form_id: params.taskType,
          tenant: tenant, // Current tenant
        })
        .first();

      if (tenantTaskDef) {
        tenantTaskDefinitionIdForTask = tenantTaskDef.task_definition_id;
        resolvedDefinitionType = 'tenant';
      } else {
        // 2. If tenantTaskDef not found, attempt to find systemTaskDef
        const systemTaskDef = await knex('system_workflow_task_definitions')
          .where({
            task_type: params.taskType,
          })
          .first();

        if (systemTaskDef) {
          systemTaskDefinitionTaskTypeForTask = systemTaskDef.task_type; // For system tasks, task_type is the ID
          resolvedDefinitionType = 'system';
        } else {
          // If neither tenant nor system definition is found, throw an error.
          // Task definitions must exist before tasks can be created.
          throw new Error(`Task definition with taskType '${params.taskType}' not found for tenant '${tenant}' or as a system definition.`);
        }
      }

      // Create the task - ensure assigned_roles and assigned_users are properly formatted JSON arrays
      console.log('DEBUG createTask - Raw params assignTo:', JSON.stringify(params.assignTo, null, 2));
      
      let assignedRoles: string[] | undefined = undefined;
      if (params.assignTo?.roles) {
        console.log('DEBUG createTask - Raw roles:', params.assignTo.roles, 'Type:', typeof params.assignTo.roles);
        
        if (typeof params.assignTo.roles === 'string') {
          assignedRoles = [params.assignTo.roles];
          console.log('DEBUG createTask - Converted string role to array:', assignedRoles);
        } else if (Array.isArray(params.assignTo.roles)) {
          assignedRoles = params.assignTo.roles;
          console.log('DEBUG createTask - Using array roles:', assignedRoles);
        } else {
          console.log('DEBUG createTask - Invalid roles format, set to undefined');
        }
      }
      
      let assignedUsers: string[] | undefined = undefined;
      if (params.assignTo?.users) {
        console.log('DEBUG createTask - Raw users:', params.assignTo.users, 'Type:', typeof params.assignTo.users);
        
        if (typeof params.assignTo.users === 'string') {
          assignedUsers = [params.assignTo.users];
          console.log('DEBUG createTask - Converted string user to array:', assignedUsers);
        } else if (Array.isArray(params.assignTo.users)) {
          assignedUsers = params.assignTo.users;
          console.log('DEBUG createTask - Using array users:', assignedUsers);
        } else {
          console.log('DEBUG createTask - Invalid users format, set to undefined');
        }
      }
      
      if (assignedRoles !== undefined && !Array.isArray(assignedRoles)) {
        console.log('DEBUG createTask - Final check: roles is not an array, forcing to undefined');
        assignedRoles = undefined;
      }
      
      if (assignedUsers !== undefined && !Array.isArray(assignedUsers)) {
        console.log('DEBUG createTask - Final check: users is not an array, forcing to undefined');
        assignedUsers = undefined;
      }
      
      // Prepare the task object with the new dual FK structure.
      // IWorkflowTask will need to be updated to reflect these new fields.
      // For now, we construct the object as expected by WorkflowTaskModel.createTask after its own update.
      const taskPayload = {
        tenant,
        execution_id: executionId,
        tenant_task_definition_id: tenantTaskDefinitionIdForTask,
        system_task_definition_task_type: systemTaskDefinitionTaskTypeForTask,
        task_definition_type: resolvedDefinitionType,
        title: params.title,
        description: params.description,
        status: WorkflowTaskStatus.PENDING,
        priority: params.priority || 'medium',
        due_date: params.dueDate ? new Date(params.dueDate).toISOString() : undefined,
        context_data: params.contextData,
        assigned_roles: assignedRoles,
        assigned_users: assignedUsers,
        created_by: userId
      };
      
      console.log('DEBUG createTask - Final task payload to be inserted:', JSON.stringify(taskPayload, null, 2));
      
      // Insert the task - capturing the returned task ID
      // WorkflowTaskModel.createTask will need to be updated to accept this payload.
      const generatedTaskId = await WorkflowTaskModel.createTask(knex, tenant, taskPayload as any); // Use 'as any' temporarily if IWorkflowTask is not yet updated
      console.log('DEBUG createTask - Task created with ID:', generatedTaskId);
      
      // Add task history entry - using the generated task ID from the database
      try {
        await WorkflowTaskModel.addTaskHistory(knex, tenant, {
          task_id: generatedTaskId, // Use the task ID returned from createTask
          tenant,
          action: 'create',
          from_status: undefined,
          to_status: WorkflowTaskStatus.PENDING,
          user_id: userId
        });
        console.log('DEBUG createTask - Task history added successfully for:', generatedTaskId);
      } catch (error) {
        console.error('Error adding task history:', error);
        // Continue even if history fails - the task is already created
      }
      
      // Create a task created event - using the generated task ID
      const eventId = `${uuidv4()}`;
      const event = {
        event_id: eventId,
        execution_id: executionId,
        event_name: TaskEventNames.taskCreated(generatedTaskId),
        event_type: 'task_created',
        tenant,
        from_state: '',
        to_state: WorkflowTaskStatus.PENDING,
        user_id: userId,
        payload: {
          taskId: generatedTaskId, // Use the generated task ID
          taskType: params.taskType,
          title: params.title,
          description: params.description,
          priority: params.priority || 'medium',
          dueDate: params.dueDate,
          // Use the same validated arrays we used for the task
          assignedRoles: assignedRoles,
          assignedUsers: assignedUsers,
          contextData: params.contextData
        },
        created_at: new Date().toISOString()
      };
      
      // Insert the event
      try {
        await knex('workflow_events').insert(event);
        console.log('DEBUG createTask - Event created successfully for task:', generatedTaskId);
      } catch (error) {
        console.error('Error creating task event:', error);
        // Continue even if event creation fails - the task is already created
      }
      
      return generatedTaskId; // Return the generated task ID from the database
    } catch (error) {
      console.error('Error creating task:', error);
      throw error;
    }
  }

  /**
   * Creates a task with an inline form definition
   * 
   * @param knex Knex instance
   * @param tenant Tenant ID
   * @param executionId Workflow execution ID
   * @param params Task and form parameters
   * @param userId User ID of the creator
   * @returns The created task ID
   */
  async createTaskWithInlineForm(
    knex: Knex,
    tenant: string,
    executionId: string,
    params: {
      title: string;
      description?: string;
      priority?: string;
      dueDate?: string | Date;
      assignTo?: {
        roles?: string[] | string;
        users?: string[] | string;
      };
      contextData?: Record<string, any>;
      form: {
        jsonSchema: Record<string, any>;
        uiSchema?: Record<string, any>;
        defaultValues?: Record<string, any>;
      };
      formCategory?: string;
    },
    userId?: string
  ): Promise<string> {
    try {
      // Start a transaction to ensure atomicity
      return knex.transaction(async (trx: Knex.Transaction) => {
        // Generate a unique form ID
        const formId = uuidv4();
        const tempTaskType = `inline_task_${formId}`;

        // Create the temporary form in the tenant's workflow_form_definitions table
        await trx('workflow_form_definitions').insert({
          form_id: formId,
          tenant: tenant,
          name: `Inline Form - ${params.title}`,
          description: `Inline form for task: ${params.title}`,
          version: '1.0',
          status: 'active',
          category: params.formCategory || 'inline_forms',
          is_temporary: true,
          created_by: userId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

        // Add the form schema
        await trx('workflow_form_schemas').insert({
          schema_id: uuidv4(),
          form_id: formId,
          tenant: tenant,
          json_schema: params.form.jsonSchema,
          ui_schema: params.form.uiSchema || {},
          default_values: params.form.defaultValues || {},
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

        // Create a task definition in the tenant's task definitions table
        const taskDefinitionId = uuidv4();
        await trx('workflow_task_definitions').insert({
          task_definition_id: taskDefinitionId,
          tenant: tenant,
          name: tempTaskType,
          description: `Auto-generated task definition for inline form`,
          form_id: formId,
          form_type: 'tenant',
          default_priority: params.priority || 'medium',
          created_by: userId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

        // Process the assignTo parameter to ensure proper array format
      let assignedRoles: string[] | undefined = undefined;
      let assignedUsers: string[] | undefined = undefined;

        if (params.assignTo?.roles) {
          if (typeof params.assignTo.roles === 'string') {
            assignedRoles = [params.assignTo.roles];
          } else if (Array.isArray(params.assignTo.roles)) {
            assignedRoles = params.assignTo.roles;
          }
        }

        if (params.assignTo?.users) {
          if (typeof params.assignTo.users === 'string') {
            assignedUsers = [params.assignTo.users];
          } else if (Array.isArray(params.assignTo.users)) {
            assignedUsers = params.assignTo.users;
          }
        }

        // Generate task ID
        const taskId = uuidv4();

        // Insert the task with references to the tenant task definition
        await trx('workflow_tasks').insert({
          task_id: taskId,
          tenant: tenant,
          execution_id: executionId,
          task_definition_type: 'tenant',
          system_task_definition_task_type: null,
          tenant_task_definition_id: taskDefinitionId,
          title: params.title,
          description: params.description,
          status: WorkflowTaskStatus.PENDING,
          priority: params.priority || 'medium',
          due_date: params.dueDate ? new Date(params.dueDate).toISOString() : null,
          context_data: params.contextData ? JSON.stringify(params.contextData) : null,
          assigned_roles: assignedRoles ? JSON.stringify(assignedRoles) : null,
          assigned_users: assignedUsers ? JSON.stringify(assignedUsers) : null,
          created_by: userId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

        // Add task history entry
        await WorkflowTaskModel.addTaskHistory(trx, tenant, {
          task_id: taskId,
          tenant: tenant,
          action: 'create',
          from_status: undefined,
          to_status: WorkflowTaskStatus.PENDING,
          user_id: userId
        });

        // Create the task created event
        await trx('workflow_events').insert({
          event_id: uuidv4(),
          execution_id: executionId,
          event_name: TaskEventNames.taskCreated(taskId),
          event_type: 'task_created',
          tenant: tenant,
          from_state: '',
          to_state: WorkflowTaskStatus.PENDING,
          user_id: userId,
          payload: {
            taskId: taskId,
            title: params.title,
            description: params.description,
            priority: params.priority || 'medium',
            dueDate: params.dueDate,
            assignedRoles: assignedRoles,
            assignedUsers: assignedUsers,
            contextData: params.contextData
          },
          created_at: new Date().toISOString()
        });

        return taskId;
      });
    } catch (error) {
      console.error('Error creating task with inline form:', error);
      throw error;
    }
  }

  /**
   * Clean up temporary forms for a specific tenant
   * 
   * @param knex Knex instance 
   * @param tenant Tenant ID
   * @returns Number of forms deleted
   */
  async cleanupTemporaryForms(knex: Knex, tenant: string): Promise<number> {
    try {
      // First get the IDs of all temporary forms for this tenant
      const tempForms = await knex('workflow_form_definitions')
        .where({ tenant: tenant, is_temporary: true })
        .select('form_id');

      if (tempForms.length === 0) {
        return 0;
      }

      const formIds = tempForms.map((f: { form_id: string }) => f.form_id);

      // Delete task definitions that reference these forms
      await knex('workflow_task_definitions')
        .where({ tenant: tenant })
        .whereIn('form_id', formIds)
        .delete();

      // Delete schemas
      await knex('workflow_form_schemas')
        .where({ tenant: tenant })
        .whereIn('form_id', formIds)
        .delete();

      // Then delete the forms themselves
      const deletedCount = await knex('workflow_form_definitions')
        .where({ tenant: tenant, is_temporary: true })
        .delete();

      console.log(`Cleaned up ${deletedCount} temporary forms for tenant ${tenant}`);
      return deletedCount;
    } catch (error) {
      console.error(`Error cleaning up temporary forms for tenant ${tenant}:`, error);
      throw error;
    }
  }

  /**
   * Clean up temporary forms for all tenants
   * 
   * @param knex Knex instance
   * @returns Total number of forms deleted
   */
  async cleanupAllTemporaryForms(knex: Knex): Promise<number> {
    try {
      // Get distinct tenants that have temporary forms
      const tenants = await knex('workflow_form_definitions')
        .where({ is_temporary: true })
        .distinct('tenant')
        .pluck('tenant');

      let totalDeleted = 0;

      // Clean up for each tenant
      for (const tenant of tenants) {
        const deleted = await this.cleanupTemporaryForms(knex, tenant);
        totalDeleted += deleted;
      }

      return totalDeleted;
    } catch (error) {
      console.error('Error cleaning up temporary forms for all tenants:', error);
      throw error;
    }
  }

  /**
   * Helper method for task creation with inline form
   * Used by the createInlineTaskAndWaitForResult action
   */
  private async createTaskWithInlineFormAction(
    params: Record<string, any>,
    context: ActionExecutionContext
  ): Promise<{ success: boolean; taskId: string | null; error?: string }> {
    try {
      // Get database connection
      const { getAdminConnection } = await import('@shared/db/admin.js');
      const knex = await getAdminConnection();
      
      // Create the task with inline form
      const taskId = await this.createTaskWithInlineForm(
        knex,
        context.tenant,
        context.executionId,
        {
          title: params.title,
          description: params.description,
          priority: params.priority,
          dueDate: params.dueDate,
          assignTo: params.assignTo,
          contextData: params.contextData,
          form: {
            jsonSchema: params.form.jsonSchema,
            uiSchema: params.form.uiSchema,
            defaultValues: params.form.defaultValues
          },
          formCategory: params.formCategory
        },
        context.userId
      );
      
      return {
        success: true,
        taskId
      };
    } catch (error) {
      console.error('Error executing create_task_with_inline_form action:', error);
      return {
        success: false,
        taskId: null,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  
  /**
   * Register a task creation action with the workflow engine
   * This allows workflows to create human tasks
   * 
   * @param actionRegistry The action registry to register with
   */
  registerTaskActions(actionRegistry: ActionRegistry): void {
    // Register create_human_task action using registerSimpleAction
    actionRegistry.registerSimpleAction(
      'create_human_task',
      'Create a human task in the Task Inbox',
      [
        { name: 'taskType', type: 'string', required: true },
        { name: 'title', type: 'string', required: true },
        { name: 'description', type: 'string', required: false },
        { name: 'priority', type: 'string', required: false },
        { name: 'dueDate', type: 'string', required: false },
        { name: 'assignTo', type: 'object', required: false },
        { name: 'contextData', type: 'object', required: false }
      ],
      async (params: Record<string, any>, context: ActionExecutionContext) => {
        try {
          const taskInboxService = new TaskInboxService();
          
          // Get database connection
          const { getAdminConnection } = await import('@shared/db/admin.js');
          const knex = await getAdminConnection();
          
          // Validate and normalize inputs
          let assignTo: { roles?: string[]; users?: string[] } | undefined = undefined;
          
          console.log('DEBUG create_human_task - Context:', {
            tenant: context.tenant,
            executionId: context.executionId,
            userId: context.userId || 'undefined', // Log userId to verify it's being passed
            idempotencyKey: context.idempotencyKey
          });
          
          console.log('DEBUG create_human_task - Input params:', JSON.stringify(params, null, 2));
          
          // Ensure assignTo is properly structured with valid array values
          if (params.assignTo) {
            console.log('DEBUG create_human_task - Original assignTo:', JSON.stringify(params.assignTo, null, 2));
            
            // Check if roles is a string and convert to array if needed
            let roles = params.assignTo.roles;
            console.log('DEBUG create_human_task - Original roles:', roles, 'Type:', typeof roles);
            
            if (typeof roles === 'string') {
              roles = [roles]; // Convert single string to array
              console.log('DEBUG create_human_task - Converted string role to array:', roles);
            } else if (!Array.isArray(roles)) {
              roles = undefined; // If not string or array, set to undefined
              console.log('DEBUG create_human_task - Invalid roles format, set to undefined');
            }
            
            // Check if users is a string and convert to array if needed
            let users = params.assignTo.users;
            console.log('DEBUG create_human_task - Original users:', users, 'Type:', typeof users);
            
            if (typeof users === 'string') {
              users = [users]; // Convert single string to array
              console.log('DEBUG create_human_task - Converted string user to array:', users);
            } else if (!Array.isArray(users)) {
              users = undefined; // If not string or array, set to undefined
              console.log('DEBUG create_human_task - Invalid users format, set to undefined');
            }
            
            assignTo = {
              roles: roles,
              users: users
            };
            
            console.log('DEBUG create_human_task - Normalized assignTo:', JSON.stringify(assignTo, null, 2));
          } else {
            console.log('DEBUG create_human_task - No assignTo provided');
          }
          
          // Create the task with validated inputs
          const taskId = await taskInboxService.createTask(
            knex,
            context.tenant,
            context.executionId,
            {
              taskType: params.taskType,
              title: params.title,
              description: params.description,
              priority: params.priority,
              dueDate: params.dueDate,
              assignTo: assignTo,
              contextData: params.contextData
            },
            context.userId
          );
          
          return {
            success: true,
            taskId
          };
        } catch (error) {
          console.error('Error executing create_human_task action:', error);
          throw error;
        }
      }
    );

    // Register create_task_with_inline_form action
    actionRegistry.registerSimpleAction(
      'create_task_with_inline_form',
      'Create a human task with an inline form definition',
      [
        { name: 'title', type: 'string', required: true },
        { name: 'description', type: 'string', required: false },
        { name: 'priority', type: 'string', required: false },
        { name: 'dueDate', type: 'string', required: false },
        { name: 'assignTo', type: 'object', required: false },
        { name: 'contextData', type: 'object', required: false },
        { name: 'form', type: 'object', required: true },
        { name: 'formCategory', type: 'string', required: false }
      ],
      async (params: Record<string, any>, context: ActionExecutionContext) => {
        const taskInboxService = new TaskInboxService();
        return taskInboxService.createTaskWithInlineFormAction(params, context);
      }
    );

    // Register the composite action for creating a task with inline form and waiting for result
    actionRegistry.registerSimpleAction(
      'createInlineTaskAndWaitForResult',
      'Create a human task with an inline form definition and wait for its completion',
      [
        { name: 'title', type: 'string', required: true },
        { name: 'description', type: 'string', required: false },
        { name: 'priority', type: 'string', required: false },
        { name: 'dueDate', type: 'string', required: false },
        { name: 'assignTo', type: 'object', required: false },
        { name: 'contextData', type: 'object', required: false },
        { name: 'form', type: 'object', required: true },
        { name: 'formCategory', type: 'string', required: false },
        { name: 'waitForEventTimeoutMilliseconds', type: 'number', required: false }
      ],
      async (params: Record<string, any>, context: ActionExecutionContext) => {
        try {
          const taskInboxService = new TaskInboxService();
          
          // Step 1: Create the task with inline form
          const createTaskResult = await taskInboxService.createTaskWithInlineFormAction(params, context);

          if (!createTaskResult.success || !createTaskResult.taskId) {
            return {
              success: false,
              taskId: null,
              error: 'Failed to create task with inline form',
              details: createTaskResult
            };
          }

          const taskId = createTaskResult.taskId;

          // Step 2: Wait for the task completion event
          try {
            // Get database connection for querying task status
            const { getAdminConnection } = await import('@shared/db/admin.js');
            const knex = await getAdminConnection();

            const taskCompletedEventName = TaskEventNames.taskCompleted(taskId);
            
            // In a real implementation, this would use the workflow context's waitFor
            // Since that's not available in ActionExecutionContext, we'll have to mock this
            // This is just a prototype implementation that polls the task status
            
            console.log(`Waiting for task completion event: ${taskCompletedEventName}`);
            
            // Poll for task completion - this is not how it would work in production
            // In production, this would use the event system, but for TypeScript validation
            // we need a simplified implementation
            
            // Set timeout
            const timeoutMs = params.waitForEventTimeoutMilliseconds || 3600000; // 1 hour default
            const startTime = Date.now();
            
            // Poll every 5 seconds
            const pollIntervalMs = 5000;
            let isCompleted = false;
            let task: IWorkflowTask | null = null;
            
            while (Date.now() - startTime < timeoutMs && !isCompleted) {
              // Check if task is completed
              task = await WorkflowTaskModel.getTaskById(knex, context.tenant, taskId);
              
              if (task && task.status === WorkflowTaskStatus.COMPLETED) {
                isCompleted = true;
                break;
              }
              
              // Wait for next poll
              await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
            }
            
            // If we timed out
            if (!isCompleted) {
              throw new Error(`Timeout waiting for task ${taskId} to complete`);
            }
            
            // Task completed successfully
            return {
              success: true,
              taskId,
              resolutionData: task?.response_data || {}
            };
          } catch (waitError) {
            // Handle timeout or other waitFor errors
            return {
              success: false,
              taskId,
              error: waitError instanceof Error ? waitError.message : 'Unknown error waiting for task completion',
              details: waitError
            };
          }
        } catch (error) {
          return {
            success: false,
            taskId: null,
            error: error instanceof Error ? error.message : 'Unknown error',
            details: error
          };
        }
      }
    );

    // Register cleanup_temporary_forms action
    actionRegistry.registerSimpleAction(
      'cleanup_temporary_forms',
      'Clean up temporary forms for a tenant',
      [
        { name: 'tenant', type: 'string', required: true }
      ],
      async (params: Record<string, any>, context: ActionExecutionContext) => {
        try {
          const taskInboxService = new TaskInboxService();
          
          // Get database connection
          const { getAdminConnection } = await import('@shared/db/admin.js');
          const knex = await getAdminConnection();
          
          // Clean up temporary forms
          const deletedCount = await taskInboxService.cleanupTemporaryForms(
            knex,
            params.tenant
          );
          
          return {
            success: true,
            deletedCount
          };
        } catch (error) {
          console.error('Error executing cleanup_temporary_forms action:', error);
          throw error;
        }
      }
    );
  }
}

// Singleton instance
let taskInboxServiceInstance: TaskInboxService | null = null;

/**
 * Get the task inbox service instance
 */
export function getTaskInboxService(): TaskInboxService {
  if (!taskInboxServiceInstance) {
    taskInboxServiceInstance = new TaskInboxService();
  }
  return taskInboxServiceInstance;
}
