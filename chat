'use client';

import React, { useState } from 'react';
import { ITicket, ITimeSheet, ITimePeriod, ITimeEntry } from '../../interfaces';
import { IUserWithRoles, ITeam } from '../../interfaces/auth.interfaces';
import { ITicketResource } from '../../interfaces/ticketResource.interfaces';
import { Button } from '../ui/Button';
import { Label } from '../ui/Label';
import { Input } from '../ui/Input';
import { Clock, Edit2, Play, Pause, StopCircle, UserPlus, X } from 'lucide-react';
import styles from './TicketDetails.module.css';
import UserPicker from '../ui/UserPicker';
import AvatarIcon from '../ui/AvatarIcon';
import { TimeEntryDialog } from '../time-management/TimeEntryDialog';
import { CompanyPicker } from '../companies/CompanyPicker';
import CustomSelect from '../ui/CustomSelect';
import { toast } from 'react-hot-toast';
import { withDataAutomationId } from '@/types/ui-reflection/withDataAutomationId';

interface TicketPropertiesProps {
  id?: string;
  ticket: ITicket;
  company: any;
  contactInfo: any;
  createdByUser: any;
  channel: any;
  elapsedTime: number;
  isRunning: boolean;
  timeDescription: string;
  team: ITeam | null;
  additionalAgents: ITicketResource[];
  availableAgents: IUserWithRoles[];
  currentTimeSheet: ITimeSheet | null;
  currentTimePeriod: ITimePeriod | null;
  userId: string;
  tenant: string;
  contacts: any[];
  companies: any[];
  companyFilterState: 'all' | 'active' | 'inactive';
  clientTypeFilter: 'all' | 'company' | 'individual';
  onStart: () => void;
  onPause: () => void;
  onStop: () => void;
  onTimeDescriptionChange: (value: string) => void;
  onAddTimeEntry: () => void;
  onCompanyClick: () => void;
  onContactClick: () => void;
  onAgentClick: (userId: string) => void;
  onAddAgent: (userId: string) => Promise<void>;
  onRemoveAgent: (assignmentId: string) => Promise<void>;
  onChangeContact: (contactId: string | null) => void;
  onChangeCompany: (companyId: string) => void;
  onCompanyFilterStateChange: (state: 'all' | 'active' | 'inactive') => void;
  onClientTypeFilterChange: (type: 'all' | 'company' | 'individual') => void;
}

const TicketProperties: React.FC<TicketPropertiesProps> = ({
  id = 'ticket-properties',
  ticket,
  company,
  contactInfo,
  createdByUser,
  channel,
  elapsedTime,
  isRunning,
  timeDescription,
  team,
  additionalAgents,
  availableAgents,
  currentTimeSheet,
  currentTimePeriod,
  userId,
  tenant,
  contacts,
  companies,
  companyFilterState,
  clientTypeFilter,
  onStart,
  onPause,
  onStop,
  onTimeDescriptionChange,
  onAddTimeEntry,
  onCompanyClick,
  onContactClick,
  onAgentClick,
  onAddAgent,
  onRemoveAgent,
  onChangeContact,
  onChangeCompany,
  onCompanyFilterStateChange,
  onClientTypeFilterChange,
}) => {
  const [showAgentPicker, setShowAgentPicker] = useState(false);
  const [showContactPicker, setShowContactPicker] = useState(false);
  const [showCompanyPicker, setShowCompanyPicker] = useState(false);
  const [selectedContactId, setSelectedContactId] = useState<string | null>(null);
  const [selectedCompanyId, setSelectedCompanyId] = useState<string | null>(null);

  const formatTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = seconds % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className="flex-shrink-0 space-y-6">
      <div {...withDataAutomationId({ id: `${id}-time-entry` })} className={`${styles['card']} p-6 space-y-4`}>
        <h2 className={`${styles['panel-header']}`}>Time Entry</h2>
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <span>Ticket Timer - #{ticket.ticket_number}</span>
            <Clock className="h-6 w-6" />
          </div>
          <div className={`${styles['digital-clock']} text-2xl flex items-center justify-between px-4`}>
            <span>{formatTime(elapsedTime)}</span>
            <div className='pl-5'>
              <svg xmlns="http://www.w3.org/2000/svg" width="17" height="21" viewBox="0 0 17 21" fill="none">
                <path d="M0.625 20.2V1L15.825 10.2571L0.625 20.2Z" fill="#000" stroke="#000" strokeWidth="0.8" />
              </svg>
            </div>
          </div>
          <div className="flex justify-center space-x-2">
            {!isRunning ? (
              <Button {...withDataAutomationId({ id: `${id}-start-btn` })} onClick={onStart} className={`w-24`} variant='soft'>
                <Play className="mr-2 h-4 w-4" /> Start
              </Button>
            ) : (
              <Button {...withDataAutomationId({ id: `${id}-pause-btn` })} onClick={onPause} className={`w-24`} variant='soft'>
                <Pause className="mr-2 h-4 w-4" /> Pause
              </Button>
            )}
            <Button {...withDataAutomationId({ id: `${id}-reset-btn` })} onClick={onStop} className={`w-24`} variant='soft'>
              <StopCircle className="mr-2 h-4 w-4" /> Reset
            </Button>
          </div>
          <div className="space-y-2">
            <Label htmlFor="description">Description</Label>
            <Input
              {...withDataAutomationId({ id: `${id}-description-input` })}
              id="description"
              value={timeDescription}
              onChange={(e) => onTimeDescriptionChange(e.target.value)}
              placeholder="Enter work description"
              className={styles['custom-input']}
            />
          </div>
          <Button
            {...withDataAutomationId({ id: `${id}-add-time-btn` })}
            type="button"
            className={`w-full mt-4 flex items-center justify-center`}
            onClick={onAddTimeEntry}
          >
            <span className="mr-2">Add time</span>
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="#D6BBFB">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
            </svg>
          </Button>
        </div>
      </div>

      <div {...withDataAutomationId({ id: `${id}-contact-info` })} className={`${styles['card']} p-6 space-y-4`}>
        <h2 className={`${styles['panel-header']}`}>Contact Info</h2>
        <div className="space-y-2">
          <div>
            <h5 className="font-bold">Contact</h5>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-2">
                  <p
                    {...withDataAutomationId({ id: `${id}-contact-name` })}
                    className="text-sm text-blue-500 cursor-pointer hover:underline"
                    onClick={onCompanyClick}
                  >
                    {company?.company_name || 'N/A'}
                  </p>
                  <Button
                    {...withDataAutomationId({ id: `${id}-edit-contact-btn` })}
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowCompanyPicker(!showCompanyPicker)}
                    className="p-1 h-auto"
                  >
                    <Edit2 className="h-3 w-3" />
                  </Button>
                </div>
                {contactInfo && showContactPicker && (
                  <Button
                    {...withDataAutomationId({ id: `${id}-remove-contact-btn` })}
                    variant="ghost"
                    size="sm"
                    onClick={() => onChangeContact(null)}
                    className="p-1 h-auto text-red-500 hover:text-red-700"
                  >
                    <X className="h-3 w-3" />
                  </Button>
                )}
              </div>
              {showContactPicker && (
                <div className="space-y-2">
                  <div className="flex items-center group">
                    <CustomSelect
                      {...withDataAutomationId({ id: `${id}-contact-select` })}
                      value={selectedContactId || contactInfo?.contact_name_id || ''}
                      onValueChange={(value) => {
                        setSelectedContactId(value);
                      }}
                      options={contacts.map((contact): { value: string; label: string } => ({
                        value: contact.contact_name_id,
                        label: contact.full_name
                      }))}
                      placeholder="Select Contact"
                    />
                  </div>
                  <div className="flex justify-end space-x-2">
                    <Button
                      {...withDataAutomationId({ id: `${id}-cancel-contact-btn` })}
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        setShowContactPicker(false);
                        setSelectedContactId(null);
                      }}
                    >
                      Cancel
                    </Button>
                    <Button
                      {...withDataAutomationId({ id: `${id}-save-contact-btn` })}
                      variant="default"
                      size="sm"
                      onClick={() => {
                        onChangeContact(selectedContactId);
                        setShowContactPicker(false);
                      }}
                    >
                      Save
                    </Button>
                  </div>
                </div>
              )}
            </div>
          </div>
          <div>
            <h5 className="font-bold">Created By</h5>
            <p className="text-sm">
              {createdByUser ? `${createdByUser.first_name} ${createdByUser.last_name}` : 'N/A'}
            </p>
          </div>
          <div>
            <h5 className="font-bold">Client</h5>
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <p
                  className="text-sm text-blue-500 cursor-pointer hover:underline"
                  onClick={onCompanyClick}
                >
                  <AvatarIcon
                    userId={ticket.assigned_to!}
                    firstName={availableAgents.find(a => a.user_id === ticket.assigned_to)?.first_name || ''}
                    lastName={availableAgents.find(a => a.user_id === ticket.assigned_to)?.last_name || ''}
                    size="sm"
                  />
                  <span className="text-sm">
                    {availableAgents.find(a => a.user_id === ticket.assigned_to)?.first_name || 'Unknown'}{' '}
                    {availableAgents.find(a => a.user_id === ticket.assigned_to)?.last_name || 'Agent'}
                  </span>
                </p>
              </div>
              ) : (
              <p className="text-sm text-gray-500">No primary agent assigned</p>
              )
            </div>

            {/* Team */}
            <div>
              <h5 className="font-bold mb-2">Team</h5>
              {team ? (
                <div className="text-sm">
                  <p>{team.team_name}</p>
                  <p className="text-gray-500">
                    Manager: {team.members.find(m => m.user_id === team.manager_id)?.first_name || 'Unknown Manager'}
                  </p>
                </div>
              ) : (
                <p className="text-sm text-gray-500">No team assigned</p>
              )}
            </div>

            {/* Additional Agents */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <h5 className="font-bold">Additional Agents</h5>
                <Button
                  {...withDataAutomationId({ id: `${id}-edit-company-btn` })}
                  variant="ghost"
                  size="sm"
                  onClick={() => setShowAgentPicker(!showAgentPicker)}
                >
                  <UserPlus className="h-4 w-4" />
                </Button>
              </div>
              {showCompanyPicker && (
                <div className="space-y-2">
                  <div className="flex items-center group relative">
                    <div className="w-full">
                      <CompanyPicker
                        {...withDataAutomationId({ id: `${id}-company-picker` })}
                        companies={companies}
                        onSelect={setSelectedCompanyId}
                        selectedCompanyId={selectedCompanyId || company?.company_id || ''}
                        filterState={companyFilterState}
                        onFilterStateChange={onCompanyFilterStateChange}
                        clientTypeFilter={clientTypeFilter}
                        onClientTypeFilterChange={onClientTypeFilterChange}
                        fitContent={false}
                      />
                    </div>
                  </div>
                  <div className="flex justify-end space-x-2">
                    <Button
                      {...withDataAutomationId({ id: `${id}-cancel-company-btn` })}
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        setShowCompanyPicker(false);
                        setSelectedCompanyId(null);
                      }}
                    >
                      Cancel
                    </Button>
                    <Button
                      {...withDataAutomationId({ id: `${id}-save-company-btn` })}
                      variant="default"
                      size="sm"
                      onClick={() => {
                        if (selectedCompanyId) {
                          onChangeCompany(selectedCompanyId);
                        }
                        setShowCompanyPicker(false);
                      }}
                    >
                      Save
                    </Button>
                  </div>
                </div>
              )}
            </div>
          </div>
          <div>
            <h5 className="font-bold">{contactInfo ? 'Contact Phone' : 'Company Phone'}</h5>
            <p className="text-sm">
              {contactInfo?.phone_number || company?.phone_no || 'N/A'}
            </p>
          </div>
          <div>
            <h5 className="font-bold">{contactInfo ? 'Contact Email' : 'Company Email'}</h5>
            <p className="text-sm">
              {contactInfo?.email || company?.email || 'N/A'}
            </p>
          </div>
        </div>
      </div>

      <div className={`${styles['card']} p-6 space-y-4`}>
        <h2 className={`${styles['panel-header']}`}>Agent team</h2>
        <div className="space-y-4">
          {/* Primary Agent */}
          <div>
            <h5 className="font-bold mb-2">Primary Agent</h5>
            {ticket.assigned_to ? (
              <div
                className="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded"
                onClick={() => onAgentClick(ticket.assigned_to!)}
              >
                <AvatarIcon
                  {...withDataAutomationId({ id: `${id}-primary-agent-avatar` })}
                  userId={ticket.assigned_to}
                  firstName={availableAgents.find(a => a.user_id === ticket.assigned_to)?.first_name || ''}
                  lastName={availableAgents.find(a => a.user_id === ticket.assigned_to)?.last_name || ''}
                  size="sm"
                />
                <span className="text-sm">
                  {availableAgents.find(a => a.user_id === ticket.assigned_to)?.first_name || 'Unknown'}{' '}
                  {availableAgents.find(a => a.user_id === ticket.assigned_to)?.last_name || 'Agent'}
                </span>
              </div>
            ) : (
              <p className="text-sm text-gray-500">No primary agent assigned</p>
            )}
          </div>

          {/* Team */}
          <div>
            <h5 className="font-bold mb-2">Team</h5>
            {team ? (
              <div className="text-sm">
                <p>{team.team_name}</p>
                <p className="text-gray-500">
                  Manager: {team.members.find(m => m.user_id === team.manager_id)?.first_name || 'Unknown Manager'}
                </p>
              </div>
            ) : (
              <p className="text-sm text-gray-500">No team assigned</p>
            )}
          </div>

          {/* Additional Agents */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <h5 className="font-bold">Additional Agents</h5>
              <Button
                {...withDataAutomationId({ id: `${id}-add-agent-btn` })}
                variant="ghost"
                size="sm"
                onClick={() => setShowAgentPicker(!showAgentPicker)}
              >
                <UserPlus className="h-4 w-4" />
              </Button>
            </div>

            {showAgentPicker && (
              <div className="mb-4">
                <UserPicker
                  {...withDataAutomationId({ id: `${id}-agent-picker` })}
                  label="Add Agent"
                  value=""
                  onValueChange={(userId) => {
                    onAddAgent(userId);
                    setShowAgentPicker(false);
                  }}
                  users={availableAgents.filter(
                    agent => !additionalAgents.some(a => a.additional_user_id === agent.user_id)
                  )}
                />
              </div>
            )}

            <div className="space-y-2">
              {additionalAgents.map((agent): JSX.Element => {
                const agentUser = availableAgents.find(u => u.user_id === agent.additional_user_id);
                return (
                  <div
                    key={agent.assignment_id}
                    className="flex items-center justify-between group hover:bg-gray-50 p-2 rounded"
                  >
                    <div
                      key={agent.assignment_id}
                      className="flex items-center justify-between group hover:bg-gray-50 p-2 rounded"
                    >
                      <AvatarIcon
                        userId={agent.additional_user_id!}
                        firstName={agentUser?.first_name || ''}
                        lastName={agentUser?.last_name || ''}
                        size="sm"
                      />
                      <span className="text-sm">
                        {agentUser?.first_name || 'Unknown'} {agentUser?.last_name || 'Agent'}
                      </span>

                    </div>
                    <Button
                      {...withDataAutomationId({ id: `${id}-remove-agent-btn` })}
                      variant="ghost"
                      size="sm"
                      className="opacity-0 group-hover:opacity-100"
                      onClick={() => onRemoveAgent(agent.assignment_id!)}
                    >
                      Remove
                    </Button>
                  </div>
                );
              })}
              {additionalAgents.length === 0 && (
                <p className="text-sm text-gray-500">No additional agents assigned</p>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TicketProperties;
'use client';

import React, { useState, useEffect } from 'react';
import { DialogContent, DialogTitle } from '@radix-ui/react-dialog';
import { Button } from '../ui/Button';
import { format } from 'date-fns';
import { IScheduleEntry, IRecurrencePattern } from '../../interfaces/schedule.interfaces';
import { WorkItemPicker } from './WorkItemPicker';
import { IWorkItem } from '../../interfaces/workItem.interfaces';
import { getWorkItemById } from '../../lib/actions/workItemActions';
import CustomSelect from '../ui/CustomSelect';
import SelectedWorkItem from './SelectedWorkItem';
import MultiUserPicker from '../ui/MultiUserPicker';
import { IUserWithRoles } from '../../interfaces/auth.interfaces';

interface EntryPopupProps {
  event: IScheduleEntry | null;
  slot: any;
  onClose: () => void;
  onSave: (entryData: Omit<IScheduleEntry, 'tenant'>) => void;
  canAssignMultipleAgents: boolean;
  users: IUserWithRoles[];
  loading?: boolean;
  error?: string | null;
}

const EntryPopup: React.FC<EntryPopupProps> = ({ 
  event, 
  slot, 
  onClose, 
  onSave, 
  canAssignMultipleAgents,
  users,
  loading = false,
  error = null
}) => {
  const [entryData, setEntryData] = useState<Omit<IScheduleEntry, 'tenant'>>(() => {
    if (event) {
      return {
        ...event,
        scheduled_start: new Date(event.scheduled_start),
        scheduled_end: new Date(event.scheduled_end),
        assigned_user_ids: event.assigned_user_ids,
      };
    } else if (slot) {
      return {
        entry_id: '',
        title: '',
        scheduled_start: new Date(slot.start),
        scheduled_end: new Date(slot.end),
        notes: '',
        created_at: new Date(),
        updated_at: new Date(),
        work_item_id: null,
        status: 'scheduled',
        work_item_type: 'ad_hoc',
        assigned_user_ids: [],
      };
    } else {
      return {
        entry_id: '',
        title: '',
        scheduled_start: new Date(),
        scheduled_end: new Date(),
        notes: '',
        created_at: new Date(),
        updated_at: new Date(),
        work_item_id: null,
        status: 'scheduled',
        work_item_type: 'ad_hoc',
        assigned_user_ids: [],
      };
    }
  });
  const [selectedWorkItem, setSelectedWorkItem] = useState<Omit<IWorkItem, 'tenant'> | null>(null);
  const [recurrencePattern, setRecurrencePattern] = useState<IRecurrencePattern | null>(null);
  const [isEditingWorkItem, setIsEditingWorkItem] = useState(false);

  useEffect(() => {
    const initializeData = () => {
      if (event) {
        setEntryData({
          ...event,
          scheduled_start: new Date(event.scheduled_start),
          scheduled_end: new Date(event.scheduled_end),
          assigned_user_ids: event.assigned_user_ids,
          work_item_id: event.work_item_id,
        });

        // Load recurrence pattern if it exists
        if (event.recurrence_pattern) {
          setRecurrencePattern({
            ...event.recurrence_pattern,
            startDate: new Date(event.recurrence_pattern.startDate),
            endDate: event.recurrence_pattern.endDate ? new Date(event.recurrence_pattern.endDate) : undefined,
          });
        }

        // Fetch work item information if editing an existing entry
        if (event.work_item_id && event.work_item_type !== 'ad_hoc') {
          getWorkItemById(event.work_item_id, event.work_item_type).then((workItem) => {
            if (workItem) {
              setSelectedWorkItem(workItem);
            }
          });
        }
      } else if (slot) {
        setEntryData({
          entry_id: '',
          title: '',
          scheduled_start: new Date(slot.start),
          scheduled_end: new Date(slot.end),
          notes: '',
          created_at: new Date(),
          updated_at: new Date(),
          work_item_id: null,
          status: 'scheduled',
          work_item_type: 'ad_hoc',
          assigned_user_ids: [],
        });
      }
    };

    initializeData();
  }, [event, slot]);

  const recurrenceOptions = [
    { value: 'none', label: 'None' },
    { value: 'daily', label: 'Daily' },
    { value: 'weekly', label: 'Weekly' },
    { value: 'monthly', label: 'Monthly' },
    { value: 'yearly', label: 'Yearly' }
  ];

  const endTypeOptions = [
    { value: 'never', label: 'Never' },
    { value: 'date', label: 'On Date' },
    { value: 'count', label: 'After' }
  ];

  const handleRecurrenceChange = (value: string) => {
    if (value === 'none') {
      setRecurrencePattern(null);
    } else {
      setRecurrencePattern(prev => ({
        frequency: value as IRecurrencePattern['frequency'],
        interval: 1,
        startDate: entryData.scheduled_start,
        endDate: undefined,
        count: undefined,
      }));
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setEntryData((prev) => ({
      ...prev,
      [name]: name === 'scheduled_start' || name === 'scheduled_end' ? new Date(value) : value,
    }));
  };

  const handleWorkItemSelect = (workItem: IWorkItem | null) => {
    setSelectedWorkItem(workItem);
    setEntryData(prev => ({
      ...prev,
      work_item_id: workItem ? workItem.work_item_id : null,
      title: workItem ? workItem.name : prev.title,
      work_item_type: workItem?.type || 'ad_hoc'
    }));
    setIsEditingWorkItem(false);
  };

  const handleEndTypeChange = (value: string) => {
    setRecurrencePattern(prev => {
      if (prev === null) return null;
      return {
        ...prev,
        endDate: value === 'date' ? new Date() : undefined,
        count: value === 'count' ? 1 : undefined
      };
    });
  };

  const handleAssignedUsersChange = (userIds: string[]) => {
    setEntryData(prev => ({
      ...prev,
      assigned_user_ids: userIds,
    }));
  };

  const handleSave = () => {
    // Ensure required fields are present
    if (!entryData.title) {
      alert('Title is required');
      return;
    }

    // Prepare entry data
    const savedEntryData = {
      ...entryData,
      recurrence_pattern: recurrencePattern || null,
      // For ad-hoc entries, ensure work_item_id is null and type is 'ad_hoc'
      work_item_id: entryData.work_item_type === 'ad_hoc' ? null : entryData.work_item_id,
      status: entryData.status || 'scheduled',
      // Ensure assigned_user_ids is an array
      assigned_user_ids: Array.isArray(entryData.assigned_user_ids) ? entryData.assigned_user_ids : []
    };

    // Log the data being saved
    console.log('Saving schedule entry:', savedEntryData);

    onSave(savedEntryData);
  };

  return (
    <DialogContent className="bg-white p-6 rounded-lg shadow-lg fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 max-w-md w-full">
      <DialogTitle className="text-xl font-bold mb-4">
        {event ? 'Edit Entry' : 'New Entry'}
      </DialogTitle>
      <div className="space-y-4">
        <div>
          <label htmlFor="work_item" className="block text-sm font-medium text-gray-700 mb-1">
            Work Item
          </label>
          {isEditingWorkItem ? (
            <WorkItemPicker
              onSelect={handleWorkItemSelect}
              existingWorkItems={[]} // Pass existing work items if needed
              initialWorkItemId={event?.work_item_id}
              initialWorkItemType={event?.work_item_type}
            />
          ) : (
            <SelectedWorkItem
              workItem={selectedWorkItem}
              onEdit={() => setIsEditingWorkItem(true)}
            />
          )}
        </div>
        {canAssignMultipleAgents && (
          <div>
            <label htmlFor="assigned_users" className="block text-sm font-medium text-gray-700 mb-1">
              Assigned Users
            </label>
            <MultiUserPicker
              values={entryData.assigned_user_ids || []}
              onValuesChange={handleAssignedUsersChange}
              users={users}
              loading={loading}
              error={error}
            />
          </div>
        )}
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-gray-700">
            Title
          </label>
          <input
            type="text"
            id="title"
            name="title"
            value={entryData.title}
            onChange={handleInputChange}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
          />
        </div>
        <div>
          <label htmlFor="scheduled_start" className="block text-sm font-medium text-gray-700">
            Start
          </label>
          <input
            type="datetime-local"
            id="scheduled_start"
            name="scheduled_start"
            value={format(entryData.scheduled_start, "yyyy-MM-dd'T'HH:mm")}
            onChange={handleInputChange}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
          />
        </div>
        <div>
          <label htmlFor="scheduled_end" className="block text-sm font-medium text-gray-700">
            End
          </label>
          <input
            type="datetime-local"
            id="scheduled_end"
            name="scheduled_end"
            value={format(entryData.scheduled_end, "yyyy-MM-dd'T'HH:mm")}
            onChange={handleInputChange}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
          />
        </div>
        <div>
          <label htmlFor="notes" className="block text-sm font-medium text-gray-700">
            Notes
          </label>
          <textarea
            id="notes"
            name="notes"
            value={entryData.notes}
            onChange={handleInputChange}
            rows={3}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
          />
        </div>
      </div>
      <div className="space-y-4">
        <div className="relative z-10">
          <CustomSelect
            label="Recurrence"
            value={recurrencePattern?.frequency || 'none'}
            onValueChange={handleRecurrenceChange}
            options={recurrenceOptions}
          />
        </div>
      </div>
      {recurrencePattern && (
        <div className="space-y-4">
          <div>
            <label htmlFor="interval" className="block text-sm font-medium text-gray-700">
              Interval
            </label>
            <input
              type="number"
              id="interval"
              name="interval"
              value={recurrencePattern.interval}
              onChange={(e) => setRecurrencePattern(prev => {
                if (prev === null) return null;
                return { ...prev, interval: parseInt(e.target.value) };
              })}
              min={1}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            />
          </div>
          <div>
            <CustomSelect
              label="End"
              value={recurrencePattern.endDate ? 'date' : recurrencePattern.count ? 'count' : 'never'}
              onValueChange={handleEndTypeChange}
              options={endTypeOptions}
            />
          </div>
          {recurrencePattern.endDate && (
            <div>
              <label htmlFor="endDate" className="block text-sm font-medium text-gray-700">
                End Date
              </label>
              <input
                type="date"
                id="endDate"
                value={format(recurrencePattern.endDate, 'yyyy-MM-dd')}
                onChange={(e) => setRecurrencePattern(prev => {
                  if (prev === null) return null;
                  return { ...prev, endDate: new Date(e.target.value) };
                })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
              />
            </div>
          )}
          {recurrencePattern.count && (
            <div>
              <label htmlFor="count" className="block text-sm font-medium text-gray-700">
                Occurrences
              </label>
              <input
                type="number"
                id="count"
                value={recurrencePattern.count}
                onChange={(e) => setRecurrencePattern(prev => {
                  if (prev === null) return null;
                  return { ...prev, count: parseInt(e.target.value) };
                })}
                min={1}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
              />
            </div>
          )}
        </div>
      )}
      <div className="mt-6 flex justify-end space-x-3">
        <Button onClick={onClose} variant="outline">
          Cancel
        </Button>
        <Button onClick={handleSave}>Save</Button>
      </div>
    </DialogContent>
  );
};

export default EntryPopup;
'use client';

import { useState, useEffect, useRef } from 'react';
import { Pencil, Trash2, MinusCircle, XCircle, Plus } from 'lucide-react';
import { Skeleton } from '../ui/Skeleton';
import { TaxRegion } from '../../types/types.d';
import { Dialog, DialogContent, DialogFooter } from '../ui/Dialog';
import { deleteTimeEntry, fetchTimeEntriesForTimeSheet } from '../../lib/actions/timeEntryActions';
import { Button } from '../ui/Button';
import { Input } from '../ui/Input';
import CustomSelect, { SelectOption } from '../ui/CustomSelect';
import { ITimeEntry, ITimeEntryWithWorkItem, ITimePeriod } from '../../interfaces/timeEntry.interfaces';
import { IWorkItem } from '../../interfaces/workItem.interfaces';
import { BsClock } from 'react-icons/bs';
import { fetchCompanyTaxRateForWorkItem, fetchServicesForTimeEntry, fetchTaxRegions } from '../../lib/actions/timeEntryActions';
import { formatISO, parseISO, setHours, setMinutes, addMinutes } from 'date-fns';
import { Switch } from '../ui/Switch';
import { useAutomationIdAndRegister } from '../../types/ui-reflection/useAutomationIdAndRegister';
import { ReflectionContainer } from '../../types/ui-reflection/ReflectionContainer';
import { ContainerComponent, ButtonComponent, FormFieldComponent } from '../../types/ui-reflection/types';

interface ITimeEntryWithNew extends Omit<ITimeEntry, 'tenant'> {
  isNew?: boolean;
  isDirty?: boolean;
  tempId?: string;
}

// Update ITimeEntryWithWorkItem interface to use string types for dates
interface ITimeEntryWithWorkItemString extends Omit<ITimeEntryWithWorkItem, 'start_time' | 'end_time'> {
  start_time: string;
  end_time: string;
}

interface TimeEntryDialogProps {
  id?: string;
  isOpen: boolean;
  onClose: () => void;
  onSave: (timeEntry: Omit<ITimeEntry, 'tenant'>) => Promise<void>;
  workItem: Omit<IWorkItem, 'tenant'>;
  date: Date;
  existingEntries?: ITimeEntryWithWorkItem[];
  timePeriod: ITimePeriod;
  isEditable: boolean;
  defaultStartTime?: Date;
  defaultEndTime?: Date;
  defaultTaxRegion?: string;
  timeSheetId?: string;
  onTimeEntriesUpdate?: (entries: ITimeEntryWithWorkItemString[]) => void;
}

interface Service {
  id: string;
  name: string;
  type: string;
  is_taxable: boolean;
}

export function TimeEntryDialog({
  id = 'time-entry-dialog',
  isOpen,
  onClose,
  onSave,
  workItem,
  date,
  existingEntries,
  timePeriod: _timePeriod,
  isEditable,
  defaultStartTime,
  defaultEndTime,
  defaultTaxRegion,
  timeSheetId,
  onTimeEntriesUpdate,
}: TimeEntryDialogProps) {
  const [entries, setEntries] = useState<(ITimeEntryWithNew & { tempId?: string })[]>([]);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [services, setServices] = useState<Service[]>([]);
  const lastNoteInputRef = useRef<HTMLInputElement>(null);
  const [totalDurations, setTotalDurations] = useState<number[]>([]);
  const [taxRegions, setTaxRegions] = useState<TaxRegion[]>([]);
  const [timeInputs, setTimeInputs] = useState<{ [key: string]: string }>({});
  const [shouldFocusNotes, setShouldFocusNotes] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        const [fetchedServices, fetchedTaxRegions] = await Promise.all([
          fetchServicesForTimeEntry(),
          fetchTaxRegions()
        ]);
        setServices(fetchedServices);
        setTaxRegions(fetchedTaxRegions);
      } catch (error) {
        console.error('Error loading data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    if (isOpen) {
      loadData();
    }
  }, [isOpen]); // Only reload when dialog opens

  useEffect(() => {
    const initializeEntries = async () => {
      let defaultTaxRegionFromCompany: string | undefined;
      
      // Fetch company tax rate if this is a ticket
      if (workItem.type === 'ticket' || workItem.type === 'project_task') {
        try {
          defaultTaxRegionFromCompany = await fetchCompanyTaxRateForWorkItem(workItem.work_item_id, workItem.type);
        } catch (error) {
          console.error('Error fetching company tax rate:', error);
        }
      }

      let newEntries: Omit<ITimeEntry, 'tenant'>[] = [];

      if (existingEntries && existingEntries.length > 0) {
        newEntries = existingEntries.map(({ tenant: _tenant, ...rest }): Omit<ITimeEntry, 'tenant'> => {
          // If entry has no tax region but we have a default, use it
          const taxRegion = rest.tax_region || defaultTaxRegion || defaultTaxRegionFromCompany;
          return {
            ...rest,
            start_time: formatISO(parseISO(rest.start_time)),
            end_time: formatISO(parseISO(rest.end_time)),
            created_at: formatISO(parseISO(rest.created_at)),
            updated_at: formatISO(parseISO(rest.updated_at)),
            tax_region: taxRegion
          };
        });
      } else if (defaultStartTime && defaultEndTime) {
        const duration = calculateDuration(defaultStartTime, defaultEndTime);
        const newEntry: ITimeEntryWithNew = {
          work_item_id: workItem.work_item_id,
          start_time: formatISO(defaultStartTime),
          end_time: formatISO(defaultEndTime),
          billable_duration: duration, // Set initial billable duration equal to total duration
          work_item_type: workItem.type,
          notes: '',
          entry_id: '',
          user_id: '',
          created_at: formatISO(new Date()),
          updated_at: formatISO(new Date()),
          approval_status: 'DRAFT',
          service_id: '',
          tax_region: defaultTaxRegion || defaultTaxRegionFromCompany || '',
          isNew: true,
          tempId: crypto.randomUUID()
        };
        newEntries.push(newEntry);
      }

      if (newEntries.length === 0) {
        const defaultStartTime = new Date(date);
        defaultStartTime.setHours(8, 0, 0, 0);
        const defaultEndTime = new Date(defaultStartTime);
        defaultEndTime.setHours(9, 0, 0, 0);
        const duration = calculateDuration(defaultStartTime, defaultEndTime);

        const emptyEntry: ITimeEntryWithNew = {
          work_item_id: workItem.work_item_id,
          start_time: formatISO(defaultStartTime),
          end_time: formatISO(defaultEndTime),
          billable_duration: duration, // Set initial billable duration equal to total duration
          work_item_type: workItem.type,
          notes: '',
          entry_id: '',
          user_id: '',
          created_at: formatISO(new Date()),
          updated_at: formatISO(new Date()),
          approval_status: 'DRAFT',
          service_id: '',
          tax_region: defaultTaxRegion || '',
          isNew: true,
          tempId: crypto.randomUUID()
        };
        newEntries.push(emptyEntry);
      }

      // Sort entries by start time
      const sortedEntries = [...newEntries].sort((a, b): number => 
        parseISO(a.start_time).getTime() - parseISO(b.start_time).getTime()
      );
      console.log('Initializing entries:', { sortedEntries });
      setEntries(sortedEntries);
      
      
      // Only show edit UI if this is a new entry with no existing entries
      if (newEntries.length === 1 && !existingEntries?.length) {
        setEditingIndex(0);
      } else {
        setEditingIndex(null);
      }
    };

    initializeEntries();
  }, [existingEntries, defaultStartTime, defaultEndTime, workItem, date, defaultTaxRegion]);

  useEffect(() => {
    if (isOpen && lastNoteInputRef.current && shouldFocusNotes) {
      lastNoteInputRef.current.focus();
      setShouldFocusNotes(false);
    }
  }, [isOpen, entries, shouldFocusNotes]);

  useEffect(() => {
    const newTotalDurations = entries.map((entry): number =>
      calculateDuration(parseISO(entry.start_time), parseISO(entry.end_time))
    );
    // Only update if durations actually changed
    if (JSON.stringify(newTotalDurations) !== JSON.stringify(totalDurations)) {
      setTotalDurations(newTotalDurations);
    }
  }, [entries, totalDurations]);

  const handleAddEntry = () => {
    if (isEditable) {
      // Get default start time based on last entry's end time or 8am
      let defaultStartTime = new Date(date);
      if (entries.length > 0) {
        // Use the end time of the last entry
        const lastEntry = entries[entries.length - 1];
        defaultStartTime = parseISO(lastEntry.end_time);
      } else {
        // For first entry, set to 8am
        defaultStartTime.setHours(8, 0, 0, 0);
      }

      // Set end time to start time + 1 hour by default
      const defaultEndTime = new Date(defaultStartTime);
      defaultEndTime.setHours(defaultEndTime.getHours() + 1);
      const duration = calculateDuration(defaultStartTime, defaultEndTime);

      // Mark this as a new entry by setting a temporary flag
      const newEntry: ITimeEntryWithNew & { tempId?: string } = {
        work_item_id: workItem.work_item_id,
        start_time: formatISO(defaultStartTime),
        end_time: formatISO(defaultEndTime),
        billable_duration: duration, // Set initial billable duration equal to total duration
        work_item_type: workItem.type,
        notes: '',
        entry_id: '',
        user_id: '',
        created_at: formatISO(new Date()),
        updated_at: formatISO(new Date()),
        approval_status: 'DRAFT',
        service_id: '',
        tax_region: defaultTaxRegion || '',
        isNew: true,
        tempId: crypto.randomUUID()
      };

      console.log('Adding new entry:', { newEntry });
      setEntries([...entries, newEntry]);
      setShouldFocusNotes(true);
    }
  };

  const handleSaveEntry = async (index: number) => {
    if (!isEditable || !timeSheetId) return;

    const entry = entries[index];
    if (!entry.service_id) {
      alert('Please select a service');
      return;
    }

    const selectedService = services.find(s => s.id === entry.service_id);
    if (selectedService?.is_taxable && !entry.tax_region) {
      alert('Please select a tax region for taxable services');
      return;
    }

    if (!validateTimeEntry(entry)) {
      return;
    }

    // Calculate duration
    const duration = calculateDuration(parseISO(entry.start_time), parseISO(entry.end_time));
    
    // Prepare entry for saving by removing UI-only properties
    const { isNew, isDirty, tempId, ...entryToSave } = entry;

    console.log('Saving entry:', {
      duration,
      billable_duration: entryToSave.billable_duration,
      entry: entryToSave
    });

    try {
      await onSave(entryToSave);
      
      // After successful save, fetch fresh data if we have a timesheet ID
      const fetchedTimeEntries = timeSheetId ? await fetchTimeEntriesForTimeSheet(timeSheetId) : [];

      // Convert fetched entries to the correct format
      const updatedEntries = fetchedTimeEntries
        .filter((entry): boolean => entry.work_item_id === workItem.work_item_id)
        .map((entry): ITimeEntryWithWorkItemString => ({
          ...entry,
          start_time: typeof entry.start_time === 'string' ? entry.start_time : formatISO(entry.start_time),
          end_time: typeof entry.end_time === 'string' ? entry.end_time : formatISO(entry.end_time)
        }));

      // Update local entries state with fresh data
      const newEntries = updatedEntries.map((entry): ITimeEntryWithNew => ({
        ...entry,
        isDirty: false,
        isNew: false
      }));
      
      // Sort entries by start time before updating state
      const sortedEntries = [...newEntries].sort((a, b) => 
        parseISO(a.start_time).getTime() - parseISO(b.start_time).getTime()
      );

      console.log('Updating state after save:', {
        sortedEntries
      });

      setEntries(sortedEntries);

      // Notify parent of all updated entries
      if (onTimeEntriesUpdate) {
        onTimeEntriesUpdate(fetchedTimeEntries.map((entry): ITimeEntryWithWorkItemString => ({
          ...entry,
          start_time: typeof entry.start_time === 'string' ? entry.start_time : formatISO(entry.start_time),
          end_time: typeof entry.end_time === 'string' ? entry.end_time : formatISO(entry.end_time)
        })));
      }
      
      // Update timeInputs to reflect the saved times
      setTimeInputs(prev => ({
        ...prev,
        [`start-${index}`]: formatTimeForInput(parseISO(entry.start_time)),
        [`end-${index}`]: formatTimeForInput(parseISO(entry.end_time))
      }));
      
      setEditingIndex(null);
    } catch (error) {
      console.error('Error saving time entry:', error);
      alert('Failed to save time entry. Please try again.');
    }
  };

  const handleClose = () => {
    // Check if there are any unsaved changes
    const hasUnsavedChanges = entries.some(entry => entry.isDirty);
    
    if (hasUnsavedChanges) {
      if (window.confirm('You have unsaved changes. Are you sure you want to close?')) {
        onClose();
      }
    } else {
      onClose();
    }
  };

  const handleStartTimeChange = (index: number, newStartTime: Date) => {
    if (isEditable) {
      const newEntries = [...entries];
      newEntries[index].start_time = formatISO(newStartTime);
      const duration = calculateDuration(newStartTime, parseISO(newEntries[index].end_time));

      // Update billable duration if entry is currently billable
      if (newEntries[index].billable_duration > 0) {
        newEntries[index].billable_duration = duration;
      }

      newEntries[index].isDirty = true;
      console.log('Updating start time:', { index, newStartTime, newEntries });
      setEntries(newEntries);
    }
  };

  const handleEndTimeChange = (index: number, newEndTime: Date) => {
    if (isEditable) {
      const newEntries = [...entries];
      newEntries[index].end_time = formatISO(newEndTime);
      const duration = calculateDuration(parseISO(newEntries[index].start_time), newEndTime);

      // Update billable duration if entry is billable
      if (newEntries[index].billable_duration > 0) {
        newEntries[index].billable_duration = duration;
      }

      console.log('Updating end time:', { index, newEndTime, newEntries });
      setEntries(newEntries);
    }
  };

  const handleTaxRegionChange = (index: number, value: string) => {
    if (isEditable) {
      const newEntries = [...entries];
      newEntries[index].tax_region = value;
      console.log('Updating tax region:', { index, value, newEntries });
      setEntries(newEntries);
    }
  };

  const handleServiceChange = async (index: number, value: string) => {
    if (isEditable) {
      const newEntries = [...entries];
      newEntries[index].service_id = value;
      const selectedService = services.find(s => s.id === value);
      
      if (selectedService?.is_taxable) {
        // Try to get default tax region for tickets and project tasks
        if (workItem.type === 'ticket' || workItem.type === 'project_task') {
          try {
            const defaultTaxRegion = await fetchCompanyTaxRateForWorkItem(workItem.work_item_id, workItem.type);
            if (defaultTaxRegion) {
              newEntries[index].tax_region = defaultTaxRegion;
            }
          } catch (error) {
            console.error('Error fetching default tax region:', error);
          }
        }
      } else {
        newEntries[index].tax_region = '';
      }
      console.log('Updating service:', { index, value, newEntries });
      setEntries(newEntries);
    }
  };

  const handleBillableToggle = (index: number, checked: boolean) => {
    if (isEditable) {
      const newEntries = [...entries];
      const entry = newEntries[index];
      const duration = calculateDuration(
        parseISO(entry.start_time),
        parseISO(entry.end_time)
      );
      
      // Set billable_duration based on toggle
      entry.billable_duration = checked ? duration : 0;
      entry.isDirty = true;

      console.log('Updating billable status:', { 
        index, 
        checked, 
        duration,
        billable_duration: entry.billable_duration,
        entry
      });

      setEntries(newEntries);
    }
  };

  const handleDurationChange = (index: number, hours: number, minutes: number) => {
    if (isEditable) {
      const newEntries = [...entries];
      const startTime = parseISO(newEntries[index].start_time);
      const newEndTime = addMinutes(startTime, hours * 60 + minutes);

      newEntries[index].end_time = formatISO(newEndTime);

      // Update billable duration if entry is billable
      if (newEntries[index].billable_duration > 0) {
        newEntries[index].billable_duration = hours * 60 + minutes;
      }

      console.log('Updating duration:', { index, hours, minutes, newEntries });
      setEntries(newEntries);

      // Update time input to match new end time
      setTimeInputs(prev => ({
        ...prev,
        [`end-${index}`]: formatTimeForInput(newEndTime)
      }));
    }
  };

  const selectedEntry = editingIndex !== null ? entries[editingIndex] : null;
  const totalDuration = editingIndex !== null ? totalDurations[editingIndex] || 0 : 0;
  const durationHours = Math.floor(totalDuration / 60);
  const durationMinutes = totalDuration % 60;

  const handleDeleteEntry = async (index: number) => {
    const entry = entries[index];
    // Only show confirmation for existing entries
    if (!entry.entry_id || window.confirm('Are you sure you want to delete this time entry?')) {
      try {
        if (entry.entry_id) {
          // Delete from database if it's an existing entry
          await deleteTimeEntry(entry.entry_id);
        }
        
        // Remove from local state
        const newEntries = [...entries];
        newEntries.splice(index, 1);
        console.log('Removing entry:', { index, entry, newEntries });
        setEntries(newEntries);
        setEditingIndex(null);
        
        if (onTimeEntriesUpdate && timeSheetId) {
          // Fetch fresh data after deletion if we have a timesheet ID
          const fetchedTimeEntries = await fetchTimeEntriesForTimeSheet(timeSheetId);
          onTimeEntriesUpdate(fetchedTimeEntries.map((entry): ITimeEntryWithWorkItemString => ({
            ...entry,
            start_time: typeof entry.start_time === 'string' ? entry.start_time : formatISO(entry.start_time),
            end_time: typeof entry.end_time === 'string' ? entry.end_time : formatISO(entry.end_time)
          })));
        }
      } catch (error) {
        console.error('Error deleting time entry:', error);
        alert('Failed to delete time entry. Please try again.');
      }
    }
  };

  return (
    <Dialog isOpen={isOpen} onClose={handleClose} title={`Edit Time Entries for ${workItem.name}`}>
      <DialogContent className="w-full max-w-4xl">
        <ReflectionContainer id={id} label="Time Entry Dialog">
          {isLoading && existingEntries?.length ? (
              <div className="space-y-4">
              {[1, 2].map((i: number): JSX.Element => (
                <div key={`skeleton-${i}`} className="border p-4 rounded">
                  <div className="space-y-4">
                    <div className="grid grid-cols-2 gap-4">
                      <Skeleton className="h-10 w-full" />
                      <Skeleton className="h-10 w-full" />
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                      <Skeleton className="h-10 w-full" />
                      <Skeleton className="h-10 w-full" />
                    </div>
                    <Skeleton className="h-10 w-full" />
                    <Skeleton className="h-10 w-full" />
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="space-y-4">
              {entries.map((entry, index): JSX.Element => (
                <div key={entry.entry_id || entry.tempId || `entry-${index}`}>
                  {editingIndex === index ? (
                    <div className="border p-4 rounded">
                      <div className="space-y-6">
                        <div className="flex justify-end items-center">
                          <div className="flex items-center">
                            {entry.isDirty && (
                              <span className="text-yellow-500 text-sm mr-2">Unsaved changes</span>
                            )}
                          </div>
                          <div className="flex space-x-2">
                            {!entry.isNew && (
                              <Button
                                {...useAutomationIdAndRegister<ButtonComponent>({
                                  id: `${id}-entry-${index}-collapse-btn`,
                                  type: 'button',
                                  label: 'Collapse Entry',
                                  actions: ['click']
                                }).automationIdProps}
                                onClick={() => setEditingIndex(null)}
                                variant="ghost"
                                size="sm"
                                className="h-10 w-10"
                                title="Collapse entry"
                              >
                                <MinusCircle className="h-6 w-6" />
                              </Button>
                            )}
                            <Button
                              {...useAutomationIdAndRegister<ButtonComponent>({
                                id: `${id}-entry-${index}-delete-btn-edit`,
                                type: 'button',
                                label: 'Delete Entry',
                                actions: ['click']
                              }).automationIdProps}
                              onClick={() => handleDeleteEntry(index)}
                              variant="ghost"
                              size="sm"
                              className="h-10 w-10 text-red-500 hover:text-red-600"
                              title="Delete entry"
                            >
                              <XCircle className="h-6 w-6" />
                            </Button>
                          </div>
                        </div>
         
                        <div className="border p-4 rounded space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Service <span className="text-red-500">*</span></label>
                    <CustomSelect
                      {...useAutomationIdAndRegister<FormFieldComponent>({
                        id: `${id}-entry-${editingIndex}-service`,
                        type: 'formField',
                        fieldType: 'select',
                        label: 'Service',
                        value: selectedEntry!.service_id || ''
                      }).automationIdProps}
                      value={selectedEntry!.service_id || ''}
                      onValueChange={(value) => handleServiceChange(editingIndex!, value)}
                      disabled={!isEditable}
                      className="mt-1 w-full"
                      options={services.map((service): SelectOption => ({
                        value: service.id,
                        label: service.name
                      }))}
                      placeholder="Select a service"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">
                      Tax Region {services.find(s => s.id === selectedEntry!.service_id)?.is_taxable && <span className="text-red-500">*</span>}
                    </label>
                    <CustomSelect
                      {...useAutomationIdAndRegister<FormFieldComponent>({
                        id: `${id}-entry-${editingIndex}-tax-region`,
                        type: 'formField',
                        fieldType: 'select',
                        label: 'Tax Region',
                        value: selectedEntry!.tax_region || ''
                      }).automationIdProps}
                      value={selectedEntry!.tax_region || ''}
                      onValueChange={(value) => handleTaxRegionChange(editingIndex!, value)}
                      disabled={!isEditable || !services.find(s => s.id === selectedEntry!.service_id)?.is_taxable}
                      className="mt-1 w-full"
                      options={taxRegions.map((region): SelectOption => ({
                        value: region.name,
                        label: region.name
                      }))}
                      placeholder="Select a tax region"
                    />
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Start Time</label>
                    <Input
                      {...useAutomationIdAndRegister<FormFieldComponent>({
                        id: `${id}-entry-${editingIndex}-start-time`,
                        type: 'formField',
                        fieldType: 'textField',
                        label: 'Start Time',
                        value: timeInputs[`start-${editingIndex}`] || formatTimeForInput(parseISO(selectedEntry!.start_time))
                      }).automationIdProps}
                      type="time"
                      value={timeInputs[`start-${editingIndex}`] || formatTimeForInput(parseISO(selectedEntry!.start_time))}
                      onChange={(e) => {
                        if (isEditable) {
                          setTimeInputs(prev => ({
                            ...prev,
                            [`start-${editingIndex}`]: e.target.value
                          }));
                        }
                      }}
                      onBlur={(e) => {
                        if (isEditable && e.target.value) {
                          const newStartTime = parseTimeToDate(e.target.value, parseISO(selectedEntry!.start_time));
                          // Don't allow start time after end time
                          if (newStartTime >= parseISO(selectedEntry!.end_time)) {
                            alert('Start time cannot be after end time');
                            // Reset to previous valid value
                            setTimeInputs(prev => ({
                              ...prev,
                              [`start-${editingIndex}`]: formatTimeForInput(parseISO(selectedEntry!.start_time))
                            }));
                            return;
                          }
                          handleStartTimeChange(editingIndex!, newStartTime);
                          setTimeInputs(prev => ({
                            ...prev,
                            [`start-${editingIndex}`]: formatTimeForInput(newStartTime)
                          }));
                        }
                      }}
                      disabled={!isEditable}
                      className="mt-1"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">End Time</label>
                    <Input
                      {...useAutomationIdAndRegister<FormFieldComponent>({
                        id: `${id}-entry-${editingIndex}-end-time`,
                        type: 'formField',
                        fieldType: 'textField',
                        label: 'End Time',
                        value: timeInputs[`end-${editingIndex}`] || formatTimeForInput(parseISO(selectedEntry!.end_time))
                      }).automationIdProps}
                      type="time"
                      value={timeInputs[`end-${editingIndex}`] || formatTimeForInput(parseISO(selectedEntry!.end_time))}
                      onChange={(e) => {
                        if (isEditable) {
                          setTimeInputs(prev => ({
                            ...prev,
                            [`end-${editingIndex}`]: e.target.value
                          }));
                        }
                      }}
                      onBlur={(e) => {
                        if (isEditable && e.target.value) {
                          const newEndTime = parseTimeToDate(e.target.value, parseISO(selectedEntry!.end_time));
                          // Don't allow end time before start time
                          if (newEndTime <= parseISO(selectedEntry!.start_time)) {
                            alert('End time cannot be before start time');
                            // Reset to previous valid value
                            setTimeInputs(prev => ({
                              ...prev,
                              [`end-${editingIndex}`]: formatTimeForInput(parseISO(selectedEntry!.end_time))
                            }));
                            return;
                          }
                          handleEndTimeChange(editingIndex!, newEndTime);
                          setTimeInputs(prev => ({
                            ...prev,
                            [`end-${editingIndex}`]: formatTimeForInput(newEndTime)
                          }));
                        }
                      }}
                      disabled={!isEditable}
                      className="mt-1"
                    />
                  </div>
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium text-gray-700">Duration</label>
                    <div className="flex items-center space-x-2">
                      <Input
                        {...useAutomationIdAndRegister<FormFieldComponent>({
                          id: `${id}-entry-${editingIndex}-duration-hours`,
                          type: 'formField',
                          fieldType: 'textField',
                          label: 'Duration Hours',
                          value: durationHours.toString()
                        }).automationIdProps}
                        type="number"
                        min="0"
                        value={durationHours}
                        onChange={(e) => {
                          const hours = Math.max(0, parseInt(e.target.value) || 0);
                          handleDurationChange(editingIndex!, hours, durationMinutes);
                        }}
                        placeholder="Hours"
                        disabled={!isEditable}
                        className="w-20"
                      />
                      <span>h</span>
                      <Input
                        {...useAutomationIdAndRegister<FormFieldComponent>({
                          id: `${id}-entry-${editingIndex}-duration-minutes`,
                          type: 'formField',
                          fieldType: 'textField',
                          label: 'Duration Minutes',
                          value: durationMinutes.toString()
                        }).automationIdProps}
                        type="number"
                        min="0"
                        max="59"
                        value={durationMinutes}
                        onChange={(e) => {
                          const minutes = Math.max(0, Math.min(59, parseInt(e.target.value) || 0));
                          handleDurationChange(editingIndex!, durationHours, minutes);
                        }}
                        placeholder="Minutes"
                        disabled={!isEditable}
                        className="w-20"
                      />
                      <span>m</span>
                    </div>
                  </div>

                  <div className="flex items-center justify-between mt-4">
                    <div className="flex items-center space-x-2">
                      <span className="text-sm font-medium text-gray-700">
                        {selectedEntry!.billable_duration > 0 ? 'Billable' : 'Non-billable'}
                      </span>
                      <Switch
                        {...useAutomationIdAndRegister<FormFieldComponent>({
                          id: `${id}-entry-${editingIndex}-billable-toggle`,
                          type: 'formField',
                          fieldType: 'checkbox',
                          label: 'Billable Toggle',
                          value: (selectedEntry!.billable_duration > 0).toString()
                        }).automationIdProps}
                        checked={selectedEntry!.billable_duration > 0}
                        onCheckedChange={(checked) => handleBillableToggle(editingIndex!, checked)}
                        className="data-[state=checked]:bg-primary-500"
                      />
                    </div>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700">Notes</label>
                  <Input
                    {...useAutomationIdAndRegister<FormFieldComponent>({
                      id: `${id}-entry-${editingIndex}-notes`,
                      type: 'formField',
                      fieldType: 'textField',
                      label: 'Notes',
                      value: selectedEntry!.notes
                    }).automationIdProps}
                    value={selectedEntry!.notes}
                    onChange={(e) => {
                      if (isEditable) {
                        const newEntries = [...entries];
                        newEntries[editingIndex!].notes = e.target.value;
                        console.log('Updating notes:', { index: editingIndex, notes: e.target.value, newEntries });
                        setEntries(newEntries);
                      }
                    }}
                    placeholder="Notes"
                    disabled={!isEditable}
                    ref={lastNoteInputRef}
                    className="mt-1 w-full"
                  />
                </div>

                <div className="flex justify-end mt-4">
                  <Button
                    {...useAutomationIdAndRegister<ButtonComponent>({
                      id: `${id}-entry-${editingIndex}-save-btn`,
                      type: 'button',
                      label: 'Save Entry',
                      actions: ['click']
                    }).automationIdProps}
                    onClick={() => handleSaveEntry(index)}
                    variant="default"
                    size="default"
                    className="w-32"
                  >
                    Save
                  </Button>
                </div>
              </div>                  </div>
                    </div>
                  ) : (
                    <div className="border p-4 rounded hover:bg-gray-50 flex items-center justify-between">
                      <div className="flex items-center space-x-4">
                        <div className="flex items-center space-x-2">
                          <BsClock className="text-gray-400" />
                          <span>{formatTimeForInput(parseISO(entry.start_time))} - {formatTimeForInput(parseISO(entry.end_time))}</span>
                        </div>
                        <span className="text-gray-600">|</span>
                        <span>{services.find(s => s.id === entry.service_id)?.name || 'No service selected'}</span>
                        {entry.notes && (
                          <>
                            <span className="text-gray-600">|</span>
                            <span className="text-gray-600 truncate max-w-[200px]">{entry.notes}</span>
                          </>
                        )}
                      </div>
                      {isEditable && (
                        <div className="flex space-x-2">
                          <Button
                            {...useAutomationIdAndRegister<ButtonComponent>({
                              id: `${id}-entry-${index}-edit-btn`,
                              type: 'button',
                              label: 'Edit Entry',
                              actions: ['click']
                            }).automationIdProps}
                            onClick={() => setEditingIndex(index)}
                            variant="ghost"
                            size="sm"
                            className="h-8 w-8 p-0"
                          >
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <Button
                            {...useAutomationIdAndRegister<ButtonComponent>({
                              id: `${id}-entry-${index}-delete-btn`,
                              type: 'button',
                              label: 'Delete Entry',
                              actions: ['click']
                            }).automationIdProps}
                            onClick={() => handleDeleteEntry(index)}
                            variant="ghost"
                            size="sm"
                            className="h-8 w-8 p-0 text-red-500 hover:text-red-600"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              ))}
              
              {isEditable && (
                <Button 
                  {...useAutomationIdAndRegister<ButtonComponent>({
                    id: `${id}-add-entry-btn`,
                    type: 'button',
                    label: 'Add Entry',
                    actions: ['click']
                  }).automationIdProps}
                  onClick={() => {
                    handleAddEntry();
                    setEditingIndex(entries.length);
                  }}
                  variant="outline"
                  className="w-full flex items-center justify-center gap-2"
                  disabled={editingIndex !== null && entries[editingIndex]?.isNew}
                >
                  <Plus className="h-4 w-4" />
                  Add Entry
                </Button>
              )}
            </div>
          )}

          <DialogFooter>
            <Button
              {...useAutomationIdAndRegister<ButtonComponent>({
                id: `${id}-close-btn`,
                type: 'button',
                label: 'Close Dialog',
                actions: ['click']
              }).automationIdProps}
              onClick={handleClose}
              variant="outline"
            >
              Close
            </Button>
          </DialogFooter>
        </ReflectionContainer>
      </DialogContent>
    </Dialog>
  );
}

// Helper functions
function formatTimeForInput(date: Date): string {
  const hours = date.getHours().toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  return `${hours}:${minutes}`;
}

function parseTimeToDate(timeString: string, baseDate: Date): Date {
  const [hours, minutes] = timeString.split(':').map((str): number => parseInt(str, 10));
  const newDate = new Date(baseDate);
  return setMinutes(setHours(newDate, hours || 0), minutes || 0);
}

function calculateDuration(startTime: Date, endTime: Date): number {
  return Math.max(0, Math.round((endTime.getTime() - startTime.getTime()) / 60000));
}

function validateTimeEntry(timeEntry: Omit<ITimeEntry, 'tenant'>): boolean {
  if (parseISO(timeEntry.start_time) >= parseISO(timeEntry.end_time)) {
    alert('Start time must be before end time');
    return false;
  }
  const duration = calculateDuration(parseISO(timeEntry.start_time), parseISO(timeEntry.end_time));
  if (timeEntry.billable_duration > duration) {
    alert('Billable duration cannot exceed total duration');
    return false;
  }
  return true;
}
