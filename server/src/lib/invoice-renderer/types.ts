/**
 * Represents the input data provided to the Wasm template engine.
 * This is a placeholder and should be expanded based on actual invoice data needs.
 */
export interface InvoiceViewModel {
  invoiceNumber: string;
  issueDate: string; // Consider using ISO8601String or a specific date format
  dueDate: string;   // Consider using ISO8601String or a specific date format
  customer: {
    name: string;
    address: string;
  };
  items: Array<{
    id: string; // Add an ID for better referencing
    description: string;
    quantity: number;
    unitPrice: number;
    total: number; // Keep pre-calculated total for now, AS can recalculate/validate
    category?: string; // Optional: For grouping items
    itemType?: 'service' | 'project' | 'product'; // Optional: For conditional rendering
  }>;
  subtotal: number;
  tax: number;
  total: number;
  notes?: string;
  // Add sample structure for side report data
  timeEntries?: Array<{
    id: string;
    date: string; // ISO8601String
    user: string;
    hours: number;
    description: string;
  }>;
}

/**
 * Represents the final output generated by the host-side renderer.
 */
export interface RenderOutput {
  html: string;
  css: string;
}

// --- Layout Data Structure (Returned by Wasm) ---
// NOTE: These types are mirrored in AssemblyScript (`assembly/types.ts`) using `json-as`.
// Ensure consistency, keeping in mind AssemblyScript/`json-as` limitations (e.g., enums become strings, number becomes f64/i32, optionality uses `| null`).

/**
 * Base interface for all layout elements.
 */
export interface LayoutElement {
  type: LayoutElementType;
  id?: string; // Optional unique identifier for elements
  style?: ElementStyle; // Optional styling rules
  // --- Pagination Hints ---
  pageBreakBefore?: boolean; // Suggests a page break before this element
  keepTogether?: boolean; // Suggests keeping this element and its direct children on the same page if possible
}

/**
 * Defines the possible types of layout elements.
 */
export enum LayoutElementType {
  // NOTE: In AssemblyScript, this enum is represented as `type LayoutElementType = string;`
  // The string values must match exactly between host and Wasm.
  Document = 'Document',
  Section = 'Section',
  Row = 'Row',
  Column = 'Column',
  Text = 'Text',
  Image = 'Image',
  // Add more types as needed (e.g., Table, List, Spacer)
}

/**
 * Represents the root of the layout structure.
 */
export interface DocumentElement extends LayoutElement {
  type: LayoutElementType.Document;
  children: LayoutElement[];
  globalStyles?: GlobalStyles; // Styles applicable to the whole document
}

/**
 * Represents a logical section of the document (e.g., header, body, footer).
 */
export interface SectionElement extends LayoutElement {
  type: LayoutElementType.Section;
  children: LayoutElement[];
}

/**
 * Represents a horizontal row, typically containing Columns.
 */
export interface RowElement extends LayoutElement {
  type: LayoutElementType.Row;
  children: ColumnElement[]; // Rows usually contain Columns
}

/**
 * Represents a vertical column within a Row.
 */
export interface ColumnElement extends LayoutElement {
  type: LayoutElementType.Column;
  children: LayoutElement[];
  // Optional: Define column span/width properties if using a grid system
  span?: number; // Example: number of grid columns to occupy
}

/**
 * Represents a block of text.
 */
export interface TextElement extends LayoutElement {
  type: LayoutElementType.Text;
  content: string;
  variant?: 'heading1' | 'heading2' | 'paragraph' | 'label' | 'caption'; // Semantic text types
}

/**
 * Represents an image.
 */
export interface ImageElement extends LayoutElement {
  type: LayoutElementType.Image;
  src: string; // URL or potentially base64 data URI
  alt?: string; // Alt text for accessibility
}

// --- Styling ---

/**
 * Represents CSS-like style properties for individual elements.
 * Use camelCase for property names (e.g., backgroundColor).
 */
export interface ElementStyle {
  // Layout & Box Model
  width?: string;
  height?: string;
  padding?: string;
  paddingTop?: string;
  paddingRight?: string;
  paddingBottom?: string;
  paddingLeft?: string;
  margin?: string;
  marginTop?: string;
  marginRight?: string;
  marginBottom?: string;
  marginLeft?: string;
  border?: string;
  borderRadius?: string;

  // Flexbox/Grid (if applicable to parent)
  flexGrow?: number;
  flexShrink?: number;
  flexBasis?: string;
  alignSelf?: 'auto' | 'flex-start' | 'flex-end' | 'center' | 'baseline' | 'stretch';

  // Typography
  fontSize?: string;
  fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | number;
  fontFamily?: string;
  textAlign?: 'left' | 'right' | 'center' | 'justify';
  lineHeight?: string | number;
  color?: string;

  // Background & Borders
  backgroundColor?: string;
  borderColor?: string;
  borderWidth?: string;
  borderStyle?: 'solid' | 'dashed' | 'dotted' | 'none'; // etc.

  // Add more CSS properties as needed
  [key: string]: string | number | undefined; // Allow arbitrary properties.
  // NOTE: The AssemblyScript `ElementStyle` type defines many common properties explicitly (like individual borders)
  // as `json-as` doesn't support index signatures well. Ensure common styles are explicitly defined if needed in AS.
}

/**
 * Represents global styles, potentially defining classes or base element styles.
 * This structure might evolve based on the renderer implementation.
 */
export interface GlobalStyles {
  // NOTE: The AssemblyScript version (`SimpleGlobalStyles`) is simplified due to `json-as` limitations,
  // currently only supporting `variables` as a Map<string, string>.
  variables?: { [key: string]: string }; // e.g., --primary-color: #ff0000
  classes?: { [className: string]: ElementStyle }; // e.g., .highlight: { backgroundColor: 'yellow' }
  baseElementStyles?: { // e.g., Apply styles to all 'Text' elements of a certain variant
    [elementType in LayoutElementType]?: {
      [variant: string]: ElementStyle;
    } | ElementStyle; // Allow styling all elements of a type or specific variants
  };
}

// --- Host Function Signatures (Placeholder) ---
// These will be refined in Task 3

export interface HostFunctions {
  // NOTE: Ensure these signatures match the `@external` declarations in AssemblyScript (`assembly/types.ts`).
  log: (message: string) => void;
  // Add other utility functions here, e.g., formatCurrency, complexMath
}

// --- Main Renderer Function Signature (Placeholder) ---
// This will be implemented in Task 4 & 5

export type RenderInvoiceFunction = (
  data: InvoiceViewModel,
  templateWasm: Buffer
) => Promise<RenderOutput>; // Assuming async operation for Wasm execution/rendering