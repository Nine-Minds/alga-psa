# Alga PSA Extension Development Guide (Runner + Iframe UI)

This guide describes how to build Enterprise Edition (v2) extensions for Alga PSA:
- Server-side handlers execute out-of-process in the Runner as Wasmtime **components** produced by `componentize-js`
- UI is rendered exclusively in sandboxed iframes
- Bundles are signed and content-addressed (sha256:...) and validated by the Registry

 Core rules: See “Correctness Rules” in the README for the canonical list. Reference gateway scaffold: [server/src/app/api/ext/[extensionId]/[[...path]]/route.ts](../../../server/src/app/api/ext/%5BextensionId%5D/%5B%5B...path%5D%5D/route.ts)

## Prerequisites

- Node.js 18+
- Component toolchain:
  - `@bytecodealliance/componentize-js` (`jco`) or another WIT-compatible pipeline
  - `@alga/extension-runtime` helpers for handlers/tests
- Familiarity with:
  - TypeScript, React (for UI)
  - Security best practices and least-privilege design

## Project Layout (Example)

```
my-extension/
├── src/
│   ├── component/                # Component handler source (TS/JS + @alga/extension-runtime)
│   │   ├── handler.ts
│   │   └── wit/                  # Generated WIT/world bindings
│   ├── ui/                       # Iframe app (Vite + React)
│   │   ├── index.html
│   │   └── src/
│   │       ├── main.tsx
│   │       └── components/
│   └── manifest.json             # Manifest v2
├── dist/
│   ├── main.wasm                 # Componentized artifact produced by jco componentize
│   └── ui/                       # Built iframe assets
├── SIGNATURE                     # Signature file (generated by CI)
├── package.json
└── README.md
```

## Step-by-step: Build + Package an Extension

1. **Scaffold directories**
   - Create `component/` for your handler sources (e.g., `component/src/handler.ts`) and copy the platform WIT definitions into `component/wit/extension-runner.wit`.
   - Add `ui/` for your static iframe app (any bundler). The host will serve files from `ui/dist` inside the bundle.
   - Place `manifest.json` at the repo root alongside `package.json`.

2. **Author the Wasmtime endpoint**
   - Install the toolchain: `npm install @alga/extension-runtime @bytecodealliance/componentize-js`.
   - Implement `handler` using the runtime helpers:
     ```ts
     // component/src/handler.ts
     import { Handler, jsonResponse } from '@alga/extension-runtime';

     export const handler: Handler = async (req, host) => {
       const secret = await host.secrets.get('api_key');
       const upstream = await host.http.fetch({
         url: 'https://httpbin.org/get',
         headers: { authorization: `Bearer ${secret}` },
       });
       return jsonResponse({ ok: true, upstream: upstream.status });
     };
     ```
   - Compile to JavaScript (e.g., `tsc` or Vite build) so `dist/js/handler.js` exists.
   - Run `jco componentize` to produce the Wasmtime component:  
     `npx jco componentize dist/js/handler.js --wit ./wit/extension-runner.wit --world-name runner --out dist/main.wasm`

3. **Add static UI assets**
   - Build your iframe application into `ui/dist` (for example, `npm run ui:build` producing `ui/dist/index.html`, JS/CSS chunks, images).
   - Reference the entry file from the manifest via `"ui": { "type": "iframe", "entry": "ui/dist/index.html" }`.

4. **Create or update `manifest.json`**
   - Include metadata, capabilities, optional `api.endpoints` (for docs/UX), and `assets` globs:
     ```json
     {
       "name": "com.example.basic",
       "publisher": "Example Inc.",
       "version": "1.0.0",
       "runtime": "wasm-js@1",
       "capabilities": ["http.fetch", "secrets.get", "log.emit"],
       "ui": { "type": "iframe", "entry": "ui/dist/index.html" },
       "api": { "endpoints": [{ "method": "POST", "path": "/ping", "handler": "ping" }] },
       "assets": ["ui/dist/**/*"]
     }
     ```

5. **Package the bundle**
   - Layout your release directory:
     ```
     dist/main.wasm
     ui/dist/**/*
     manifest.json
     precompiled/ (optional cwasm artifacts)
     ```
   - Create the canonical tarball (zstd recommended):  
     `tar --zstd -cf bundle.tar.zst manifest.json dist/main.wasm ui/dist`
   - Compute the content hash: `shasum -a 256 bundle.tar.zst` → `sha256:...`
   - Produce `SIGNATURE` (detached) with your publisher key per [security_signing.md](security_signing.md).

6. **Publish & install**
   - Upload `bundle.tar.zst`, `manifest.json`, `SIGNATURE`, and metadata via your CI/registry flow.
   - During tenant installation, operators provide install-scoped config and secrets that the gateway will pass to the runner.

With these steps, the Runner can fetch your component, serve the static UI, and execute the Wasmtime handler when `/api/ext/{extensionId}/...` is invoked.

## Manifest v2 (abridged)

See [Manifest Schema](manifest_schema.md) for full details.

```json
{
  "name": "com.acme.my-extension",
  "publisher": "Acme Inc.",
  "version": "1.0.0",
  "runtime": "wasm-js@1",
  "capabilities": ["http.fetch", "storage.kv", "secrets.get"],
  "ui": { "type": "iframe", "entry": "ui/index.html" },
  "api": {
    "endpoints": [
      { "method": "GET", "path": "/agreements", "handler": "agreements/list" },
      { "method": "POST", "path": "/agreements/sync", "handler": "agreements/sync" }
    ]
  },
  "assets": ["ui/**/*"]
}
```

Key points:
- `ui.entry` points to your iframe HTML within the bundle.
- `api.endpoints` describe your HTTP surface area for docs and telemetry. (Enforcement is currently advisory; see [manifest schema](manifest_schema.md) for details.)
- `capabilities` request access to host features (http, storage, secrets, ui proxy, logging) and are granted per tenant install.

## Building Server Handlers (Componentized WASM)

- Write handlers in TypeScript (or JS) using `@alga/extension-runtime`, then run `jco componentize` to produce `dist/main.wasm`.
- Optional: use other WIT-compatible languages (`wit-bindgen` for Rust/TinyGo) as long as the output conforms to the `alga:extension/runner` world.
- Use host APIs (capability-scoped) exposed via the generated bindings:
  - `host.http.fetch`, `host.storage.*`, `host.secrets.get`, `host.uiProxy.callRoute`, `host.logging.*`.

Conceptual handler shape:
```ts
import { Handler, jsonResponse } from '@alga/extension-runtime';

export const handler: Handler = async (request, host) => {
  const items = await host.storage.list({
    namespace: 'agreements',
    limit: 50,
  });
  return jsonResponse(
    { data: items },
    { headers: { 'content-type': 'application/json' } }
  );
};
```

Build example:
```bash
npm run build          # compiles TS → JS
npm run build:component
# scripts should run:
# jco componentize dist/js/handler.js --wit ./wit/extension-runner.wit \
#   --world-name runner --out dist/main.wasm
```

CI should output `dist/main.wasm` plus optional `precompiled/` artifacts referenced by the manifest.

## Building the Iframe UI

- Use the provided SDKs:
  - `@alga/extension-iframe-sdk` for host communication (auth, theme, navigation)
  - `@alga/ui-kit` for accessible, consistent components
- Iframe bootstrap and URL construction are handled by the host via:
  - [buildExtUiSrc()](../../../server/src/lib/extensions/ui/iframeBridge.ts:38)
  - [bootstrapIframe()](../../../server/src/lib/extensions/ui/iframeBridge.ts:45)
- UI assets are served by the Runner at `${RUNNER_PUBLIC_BASE}/ext-ui/{extensionId}/{content_hash}/[...]` with immutable caching

Fetching via the Gateway from your UI:
```ts
const url = `/api/ext/${context.extensionId}/agreements`;
const res = await fetch(url, { headers: context.authHeaders });
const data = await res.json();
```

## Signing and Packaging

- Produce a content-addressed bundle including:
  - `manifest.json`
  - WASM artifacts under `dist/`
  - UI assets under `ui/`
  - Optional precompiled artifacts (cwasm) under `precompiled/`
- Generate a SHA256 for the canonical bundle; sign with your publisher certificate; include `SIGNATURE`
- CI outputs an artifact ready for publish (e.g., `bundle.tar.zst`)

See [Security & Signing](security_signing.md).

## Publish and Install

- Publish the bundle and metadata to the Registry
- Admin installs a version for a tenant and grants capabilities
- The app server does not store or execute tenant code; bundles are verified and referenced via `content_hash`

## Calling Your Handlers (Gateway)

- Host exposes `/api/ext/[extensionId]/[[...path]]`.
- Gateway resolves install → version/content hash → config/providers/sealed secrets and calls Runner `POST /v1/execute` with that metadata.
- Header/time/size policies are enforced by the Gateway and Runner.
- Manifest endpoint lists are used for documentation/UX; strict enforcement is under active discussion (see [plan](../plans/2025-11-12-extension-system-alignment-plan.md)).

Reference route scaffold: [server/src/app/api/ext/[extensionId]/[[...path]]/route.ts](../../../server/src/app/api/ext/%5BextensionId%5D/%5B%5B...path%5D%5D/route.ts)

## Local Development Tips

- Use the new pluggable runner backend to switch between Knative (`RUNNER_BACKEND=knative`) and the local Docker runner (`RUNNER_BACKEND=docker`).
  - Start the runner container: `npm run runner:up` (stops with `npm run runner:down`).
  - Launch the app with Docker backend defaults: `npm run dev:runner` (sets `RUNNER_DOCKER_HOST=http://localhost:${RUNNER_DOCKER_PORT:-8085}` and proxies UI assets through `/runner/*`).
  - Override runner URLs via `.env.runner` (see `.env.runner.example`) if you are using alternative S3 or registry endpoints.
- Keep UI bundles small; leverage code splitting where appropriate
- Use the iframe SDK’s theme APIs to adapt to host styling
- Validate endpoint inputs/outputs and include clear error responses

## Best Practices

- Least privilege: request only necessary capabilities
- Input validation and resource bounds: avoid large responses; paginate/filter server-side
- Emit structured logs/metrics via Host API to support observability
- Prefer deterministic builds; maintain SBOMs; update dependencies proactively

## References

- [Manifest Schema](manifest_schema.md)
- [API Routing Guide](api-routing-guide.md)
- [Security & Signing](security_signing.md)
- [Runner](runner.md)
- [Sample Extension](sample_template.md)
- Iframe bootstrap and src builder: [server/src/lib/extensions/ui/iframeBridge.ts](../../../server/src/lib/extensions/ui/iframeBridge.ts:38)
