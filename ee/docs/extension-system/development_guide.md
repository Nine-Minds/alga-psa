# Alga PSA Extension Development Guide (Runner + Iframe UI)
> Status
>
> This guide targets the Enterprise architecture. The API gateway route `/api/ext/[extensionId]/[...]` and Runner-backed execution are in progress; a dev/mock route exists at `/api/extensions` (see [ee/server/src/app/api/extensions/route.ts](ee/server/src/app/api/extensions/route.ts)). Dynamic import of tenant UI in the host is deprecated; build iframe-only UIs (see [ee/server/src/lib/extensions/ui/ExtensionRenderer.tsx](ee/server/src/lib/extensions/ui/ExtensionRenderer.tsx) and [ee/server/src/lib/extensions/ui/iframeBridge.ts](ee/server/src/lib/extensions/ui/iframeBridge.ts)).

Notes for current development:
- Gateway usage examples below are specification examples; until `/api/ext/...` lands, wire your local UI to mocks or a local Runner stub.
- Follow iframe security expectations: default sandbox is `allow-scripts`, avoid `allow-same-origin` unless explicitly approved, and respect origin validation and the bootstrap postMessage contract (see [ee/server/src/lib/extensions/ui/iframeBridge.ts](ee/server/src/lib/extensions/ui/iframeBridge.ts)).

This guide explains how to build Enterprise Edition extensions for Alga PSA using the new multi‑tenant architecture:
- Server‑side handlers executed by an out‑of‑process Runner (WASM first)
- UI rendered exclusively via sandboxed iframes
- Signed, content‑addressed bundles with Manifest v2

## Prerequisites

- Node.js 18+
- Rust toolchain (for Runner‑targeted modules where applicable) or AssemblyScript toolchain
- Familiarity with TypeScript, React (for UI), and basic security best practices

## Project Layout (Example)

```
my-extension/
├── src/
│   ├── http/                     # Server handlers (compiled to WASM)
│   │   ├── list_agreements.ts    # or AssemblyScript/Rust
│   │   └── sync.ts
│   ├── ui/                       # Iframe app (Vite + React)
│   │   ├── index.html
│   │   └── src/
│   │       ├── main.tsx
│   │       └── components/
│   └── manifest.json             # Manifest v2
├── dist/
│   ├── main.wasm                 # Built artifact(s)
│   └── ui/                       # Built iframe assets
├── SIGNATURE                     # Signature file (generated by CI)
├── package.json
└── README.md
```

## Manifest v2 (abridged)

See [Manifest Schema](manifest_schema.md) for full details.

```json
{
  "name": "com.acme.my-extension",
  "publisher": "Acme Inc.",
  "version": "1.0.0",
  "runtime": "wasm-js@1",
  "capabilities": ["http.fetch", "storage.kv"],
  "ui": {
    "type": "iframe",
    "entry": "ui/index.html"
  },
  "api": {
    "endpoints": [
      { "method": "GET", "path": "/agreements", "handler": "dist/handlers/http/list_agreements" },
      { "method": "POST", "path": "/agreements/sync", "handler": "dist/handlers/http/sync" }
    ]
  },
  "assets": ["ui/**/*"]
}
```

## Building Server Handlers (WASM)

- Author handlers in AssemblyScript or Rust targeting WASI‑compatible WASM
- Use the Host API types to call `storage`, `http.fetch`, `secrets`, `log`, `metrics`

Handler shape (conceptual):
```ts
export async function list_agreements(ctx) {
  const items = await ctx.storage.list({ namespace: 'agreements' });
  return {
    status: 200,
    headers: { 'content-type': 'application/json' },
    body: { data: items }
  };
}
```

Compile steps depend on the chosen language; your CI should produce `dist/main.wasm` and any additional handler modules.

## Building the Iframe UI

- Use the provided SDKs:
  - `@alga/extension-iframe-sdk` for host communication (auth, theme, navigation)
  - `@alga/ui-kit` for accessible, consistent components

Fetching via the gateway:
```ts
const url = `/api/ext/${context.extensionId}/agreements`;
const res = await fetch(url, { headers: context.authHeaders });
const data = await res.json();
```

## Signing and Packaging

- Produce a content‑addressed bundle:
  - Include `manifest.json`, WASM artifacts under `dist/`, UI assets under `ui/`, and optional precompiled artifacts
- Generate a SHA256 of the canonical bundle, sign it with your developer certificate, and include `SIGNATURE`
- CI should output an artifact ready for publish (e.g., `bundle.tar.zst`)

See [Security & Signing](security_signing.md) for details.

## Publish and Install

- Publish the bundle and metadata to the Registry
- Admin installs a specific version for a tenant and grants capabilities
- No code is uploaded to the app server filesystem

## Calling Your Handlers (Gateway)

- The host exposes `/api/ext/[extensionId]/[...path]`
- Endpoints must be declared in your manifest and will be resolved at runtime
- The gateway proxies to Runner `/v1/execute` under strict header/time/size policies

## Local Development Tips

- Stub handlers in a local Runner or use mock responses while building UI
- Keep UI bundles small; use code splitting where appropriate
- Use the SDK’s theme APIs to adapt to host styling

## Best Practices

- Principle of least privilege: request only needed capabilities
- Validate and bound inputs; design clear error responses
- Avoid large responses; paginate and filter on server side
- Emit structured logs and metrics via the Host API

## Migration Notes (Legacy → New)

- Descriptor rendering inside host is deprecated; build iframe UI instead
- Replace `/api/extensions/...` with `/api/ext/...`
- Publish signed bundles; do not upload code to the server

## References

- [Manifest Schema](manifest_schema.md)
- [API Routing Guide](api-routing-guide.md)
- [Security & Signing](security_signing.md)
- [Sample Extension](sample_template.md)
