# Alga PSA Extension Development Guide (Runner + Iframe UI)

This guide describes how to build Enterprise Edition (v2) extensions for Alga PSA:
- Server-side handlers execute out-of-process in the Runner (WASM-first)
- UI is rendered exclusively in sandboxed iframes
- Bundles are signed and content-addressed (sha256:...) and validated by the Registry

 Core rules: See “Correctness Rules” in the README for the canonical list. Reference gateway scaffold: [ee/server/src/app/api/ext/[extensionId]/[...path]/route.ts](ee/server/src/app/api/ext/%5BextensionId%5D/%5B...path%5D/route.ts)

## Prerequisites

- Node.js 18+
- WASM toolchain:
  - AssemblyScript or Rust targeting WASI-compatible WASM
- Familiarity with:
  - TypeScript, React (for UI)
  - Security best practices and least-privilege design

## Project Layout (Example)

```
my-extension/
├── src/
│   ├── http/                     # Server handlers (compiled to WASM)
│   │   ├── list_agreements.ts    # or AssemblyScript/Rust
│   │   └── sync.ts
│   ├── ui/                       # Iframe app (Vite + React)
│   │   ├── index.html
│   │   └── src/
│   │       ├── main.tsx
│   │       └── components/
│   └── manifest.json             # Manifest v2
├── dist/
│   ├── main.wasm                 # Built artifact(s)
│   └── ui/                       # Built iframe assets
├── SIGNATURE                     # Signature file (generated by CI)
├── package.json
└── README.md
```

## Manifest v2 (abridged)

See [Manifest Schema](manifest_schema.md) for full details.

```json
{
  "name": "com.acme.my-extension",
  "publisher": "Acme Inc.",
  "version": "1.0.0",
  "runtime": "wasm-js@1",
  "capabilities": ["http.fetch", "storage.kv", "secrets.get"],
  "ui": { "type": "iframe", "entry": "ui/index.html" },
  "api": {
    "endpoints": [
      { "method": "GET", "path": "/agreements", "handler": "dist/handlers/http/list_agreements" },
      { "method": "POST", "path": "/agreements/sync", "handler": "dist/handlers/http/sync" }
    ]
  },
  "assets": ["ui/**/*"]
}
```

Key points:
- ui.entry points to your iframe HTML within the bundle
- api.endpoints define the HTTP surface area your extension exposes via the Gateway
- capabilities request access to host features and are granted at install time

## Building Server Handlers (WASM)

- Author handlers in AssemblyScript or Rust targeting WASI-compatible WASM
- Use host APIs (capability-scoped) to perform work:
  - storage.kv, http.fetch, secrets.get, log, metrics

Conceptual handler shape:
```ts
export async function list_agreements(ctx) {
  const items = await ctx.storage.list({ namespace: "agreements" });
  return {
    status: 200,
    headers: { "content-type": "application/json" },
    body: { data: items }
  };
}
```

CI should produce `dist/main.wasm` and any handler modules referenced by `api.endpoints.handler`.

## Building the Iframe UI

- Use the provided SDKs:
  - `@alga/extension-iframe-sdk` for host communication (auth, theme, navigation)
  - `@alga/ui-kit` for accessible, consistent components
- Iframe bootstrap and URL construction are handled by the host via:
  - [buildExtUiSrc()](ee/server/src/lib/extensions/ui/iframeBridge.ts:38)
  - [bootstrapIframe()](ee/server/src/lib/extensions/ui/iframeBridge.ts:45)
- UI assets are served by the Runner at `${RUNNER_PUBLIC_BASE}/ext-ui/{extensionId}/{content_hash}/[...]` with immutable caching

Fetching via the Gateway from your UI:
```ts
const url = `/api/ext/${context.extensionId}/agreements`;
const res = await fetch(url, { headers: context.authHeaders });
const data = await res.json();
```

## Signing and Packaging

- Produce a content-addressed bundle including:
  - `manifest.json`
  - WASM artifacts under `dist/`
  - UI assets under `ui/`
  - Optional precompiled artifacts (cwasm) under `precompiled/`
- Generate a SHA256 for the canonical bundle; sign with your publisher certificate; include `SIGNATURE`
- CI outputs an artifact ready for publish (e.g., `bundle.tar.zst`)

See [Security & Signing](security_signing.md).

## Publish and Install

- Publish the bundle and metadata to the Registry
- Admin installs a version for a tenant and grants capabilities
- The app server does not store or execute tenant code; bundles are verified and referenced via `content_hash`

## Calling Your Handlers (Gateway)

- Host exposes `/api/ext/[extensionId]/[...path]`
- Endpoints must be declared in your manifest
- Gateway resolves install → version → endpoint and calls Runner `POST /v1/execute`
- Header/time/size policies are enforced by the Gateway and Runner

Reference route scaffold: [ee/server/src/app/api/ext/[extensionId]/[...path]/route.ts](ee/server/src/app/api/ext/%5BextensionId%5D/%5B...path%5D/route.ts)

## Local Development Tips

- Use the new pluggable runner backend to switch between Knative (`RUNNER_BACKEND=knative`) and the local Docker runner (`RUNNER_BACKEND=docker`).
  - Start the runner container: `npm run runner:up` (stops with `npm run runner:down`).
  - Launch the app with Docker backend defaults: `npm run dev:runner` (sets `RUNNER_DOCKER_HOST=http://localhost:${RUNNER_DOCKER_PORT:-8085}` and proxies UI assets through `/runner/*`).
  - Override runner URLs via `.env.runner` (see `.env.runner.example`) if you are using alternative S3 or registry endpoints.
- Keep UI bundles small; leverage code splitting where appropriate
- Use the iframe SDK’s theme APIs to adapt to host styling
- Validate endpoint inputs/outputs and include clear error responses

## Best Practices

- Least privilege: request only necessary capabilities
- Input validation and resource bounds: avoid large responses; paginate/filter server-side
- Emit structured logs/metrics via Host API to support observability
- Prefer deterministic builds; maintain SBOMs; update dependencies proactively

## References

- [Manifest Schema](manifest_schema.md)
- [API Routing Guide](api-routing-guide.md)
- [Security & Signing](security_signing.md)
- [Runner](runner.md)
- [Sample Extension](sample_template.md)
- Iframe bootstrap and src builder: [ee/server/src/lib/extensions/ui/iframeBridge.ts](ee/server/src/lib/extensions/ui/iframeBridge.ts:38)
